/*
 * Cloudflare API
 * To get started using Cloudflare's products and services via the API, refer to [how to interact with Cloudflare](https://developers.cloudflare.com/fundamentals/basic-tasks/interact-with-cloudflare/), which covers using tools like [Terraform](https://developers.cloudflare.com/terraform/#cloudflare-terraform) and the [official SDKs](https://developers.cloudflare.com/fundamentals/api/reference/sdks/) to maintain your Cloudflare resources.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * The version of the OpenAPI document: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package cloudflare.sdk;

import cloudflare.ApiCallback;
import cloudflare.ApiClient;
import cloudflare.ApiException;
import cloudflare.ApiResponse;
import cloudflare.Configuration;
import cloudflare.Pair;
import cloudflare.ProgressRequestBody;
import cloudflare.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import cloudflare.sdk.models.MagicIpsecTunnelsDeleteIpsecTunnel4XXResponse;
import cloudflare.sdk.models.MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnels4xxResponse;
import cloudflare.sdk.models.MagicIpsecTunnelsListIpsecTunnelDetails4XXResponse;
import cloudflare.sdk.models.MagicIpsecTunnelsListIpsecTunnels4XXResponse;
import cloudflare.sdk.models.MagicIpsecTunnelsUpdateIpsecTunnel4XXResponse;
import cloudflare.sdk.models.MagicIpsecTunnelsUpdateMultipleIpsecTunnels4XXResponse;
import cloudflare.sdk.models.MagicPskGenerationResponse;
import cloudflare.sdk.models.MagicSchemasModifiedTunnelsCollectionResponse;
import cloudflare.sdk.models.MagicSchemasTunnelAddRequest;
import cloudflare.sdk.models.MagicSchemasTunnelDeletedResponse;
import cloudflare.sdk.models.MagicSchemasTunnelModifiedResponse;
import cloudflare.sdk.models.MagicSchemasTunnelSingleResponse;
import cloudflare.sdk.models.MagicSchemasTunnelUpdateRequest;
import cloudflare.sdk.models.MagicSchemasTunnelsCollectionResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MagicIPsecTunnelsApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public MagicIPsecTunnelsApi() {
        this(Configuration.getDefaultApiClient());
    }

    public MagicIPsecTunnelsApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for magicIpsecTunnelsCreateIpsecTunnels
     * @param accountId  (required)
     * @param magicSchemasTunnelAddRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Create IPsec tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Create IPsec tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call magicIpsecTunnelsCreateIpsecTunnelsCall(String accountId, MagicSchemasTunnelAddRequest magicSchemasTunnelAddRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = magicSchemasTunnelAddRequest;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/magic/ipsec_tunnels"
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call magicIpsecTunnelsCreateIpsecTunnelsValidateBeforeCall(String accountId, MagicSchemasTunnelAddRequest magicSchemasTunnelAddRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling magicIpsecTunnelsCreateIpsecTunnels(Async)");
        }

        // verify the required parameter 'magicSchemasTunnelAddRequest' is set
        if (magicSchemasTunnelAddRequest == null) {
            throw new ApiException("Missing the required parameter 'magicSchemasTunnelAddRequest' when calling magicIpsecTunnelsCreateIpsecTunnels(Async)");
        }

        return magicIpsecTunnelsCreateIpsecTunnelsCall(accountId, magicSchemasTunnelAddRequest, _callback);

    }

    /**
     * Create IPsec tunnels
     * Creates new IPsec tunnels associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.
     * @param accountId  (required)
     * @param magicSchemasTunnelAddRequest  (required)
     * @return MagicSchemasTunnelsCollectionResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Create IPsec tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Create IPsec tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public MagicSchemasTunnelsCollectionResponse magicIpsecTunnelsCreateIpsecTunnels(String accountId, MagicSchemasTunnelAddRequest magicSchemasTunnelAddRequest) throws ApiException {
        ApiResponse<MagicSchemasTunnelsCollectionResponse> localVarResp = magicIpsecTunnelsCreateIpsecTunnelsWithHttpInfo(accountId, magicSchemasTunnelAddRequest);
        return localVarResp.getData();
    }

    /**
     * Create IPsec tunnels
     * Creates new IPsec tunnels associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.
     * @param accountId  (required)
     * @param magicSchemasTunnelAddRequest  (required)
     * @return ApiResponse&lt;MagicSchemasTunnelsCollectionResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Create IPsec tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Create IPsec tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MagicSchemasTunnelsCollectionResponse> magicIpsecTunnelsCreateIpsecTunnelsWithHttpInfo(String accountId, MagicSchemasTunnelAddRequest magicSchemasTunnelAddRequest) throws ApiException {
        okhttp3.Call localVarCall = magicIpsecTunnelsCreateIpsecTunnelsValidateBeforeCall(accountId, magicSchemasTunnelAddRequest, null);
        Type localVarReturnType = new TypeToken<MagicSchemasTunnelsCollectionResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create IPsec tunnels (asynchronously)
     * Creates new IPsec tunnels associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.
     * @param accountId  (required)
     * @param magicSchemasTunnelAddRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Create IPsec tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Create IPsec tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call magicIpsecTunnelsCreateIpsecTunnelsAsync(String accountId, MagicSchemasTunnelAddRequest magicSchemasTunnelAddRequest, final ApiCallback<MagicSchemasTunnelsCollectionResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = magicIpsecTunnelsCreateIpsecTunnelsValidateBeforeCall(accountId, magicSchemasTunnelAddRequest, _callback);
        Type localVarReturnType = new TypeToken<MagicSchemasTunnelsCollectionResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for magicIpsecTunnelsDeleteIpsecTunnel
     * @param tunnelIdentifier  (required)
     * @param accountId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Delete IPsec Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Delete IPsec Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call magicIpsecTunnelsDeleteIpsecTunnelCall(String tunnelIdentifier, String accountId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/magic/ipsec_tunnels/{tunnel_identifier}"
            .replace("{" + "tunnel_identifier" + "}", localVarApiClient.escapeString(tunnelIdentifier.toString()))
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call magicIpsecTunnelsDeleteIpsecTunnelValidateBeforeCall(String tunnelIdentifier, String accountId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tunnelIdentifier' is set
        if (tunnelIdentifier == null) {
            throw new ApiException("Missing the required parameter 'tunnelIdentifier' when calling magicIpsecTunnelsDeleteIpsecTunnel(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling magicIpsecTunnelsDeleteIpsecTunnel(Async)");
        }

        return magicIpsecTunnelsDeleteIpsecTunnelCall(tunnelIdentifier, accountId, _callback);

    }

    /**
     * Delete IPsec Tunnel
     * Disables and removes a specific static IPsec Tunnel associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.
     * @param tunnelIdentifier  (required)
     * @param accountId  (required)
     * @return MagicSchemasTunnelDeletedResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Delete IPsec Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Delete IPsec Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public MagicSchemasTunnelDeletedResponse magicIpsecTunnelsDeleteIpsecTunnel(String tunnelIdentifier, String accountId) throws ApiException {
        ApiResponse<MagicSchemasTunnelDeletedResponse> localVarResp = magicIpsecTunnelsDeleteIpsecTunnelWithHttpInfo(tunnelIdentifier, accountId);
        return localVarResp.getData();
    }

    /**
     * Delete IPsec Tunnel
     * Disables and removes a specific static IPsec Tunnel associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.
     * @param tunnelIdentifier  (required)
     * @param accountId  (required)
     * @return ApiResponse&lt;MagicSchemasTunnelDeletedResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Delete IPsec Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Delete IPsec Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MagicSchemasTunnelDeletedResponse> magicIpsecTunnelsDeleteIpsecTunnelWithHttpInfo(String tunnelIdentifier, String accountId) throws ApiException {
        okhttp3.Call localVarCall = magicIpsecTunnelsDeleteIpsecTunnelValidateBeforeCall(tunnelIdentifier, accountId, null);
        Type localVarReturnType = new TypeToken<MagicSchemasTunnelDeletedResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete IPsec Tunnel (asynchronously)
     * Disables and removes a specific static IPsec Tunnel associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.
     * @param tunnelIdentifier  (required)
     * @param accountId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Delete IPsec Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Delete IPsec Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call magicIpsecTunnelsDeleteIpsecTunnelAsync(String tunnelIdentifier, String accountId, final ApiCallback<MagicSchemasTunnelDeletedResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = magicIpsecTunnelsDeleteIpsecTunnelValidateBeforeCall(tunnelIdentifier, accountId, _callback);
        Type localVarReturnType = new TypeToken<MagicSchemasTunnelDeletedResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnels
     * @param tunnelIdentifier  (required)
     * @param accountId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Generate Pre Shared Key (PSK) for IPsec tunnels response </td><td>  -  </td></tr>
        <tr><td> 4xx </td><td> Generate Pre Shared Key (PSK) for IPsec tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsCall(String tunnelIdentifier, String accountId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/magic/ipsec_tunnels/{tunnel_identifier}/psk_generate"
            .replace("{" + "tunnel_identifier" + "}", localVarApiClient.escapeString(tunnelIdentifier.toString()))
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsValidateBeforeCall(String tunnelIdentifier, String accountId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tunnelIdentifier' is set
        if (tunnelIdentifier == null) {
            throw new ApiException("Missing the required parameter 'tunnelIdentifier' when calling magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnels(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnels(Async)");
        }

        return magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsCall(tunnelIdentifier, accountId, _callback);

    }

    /**
     * Generate Pre Shared Key (PSK) for IPsec tunnels
     * Generates a Pre Shared Key for a specific IPsec tunnel used in the IKE session. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes. After a PSK is generated, the PSK is immediately persisted to Cloudflare&#39;s edge and cannot be retrieved later. Note the PSK in a safe place.
     * @param tunnelIdentifier  (required)
     * @param accountId  (required)
     * @return MagicPskGenerationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Generate Pre Shared Key (PSK) for IPsec tunnels response </td><td>  -  </td></tr>
        <tr><td> 4xx </td><td> Generate Pre Shared Key (PSK) for IPsec tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public MagicPskGenerationResponse magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnels(String tunnelIdentifier, String accountId) throws ApiException {
        ApiResponse<MagicPskGenerationResponse> localVarResp = magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsWithHttpInfo(tunnelIdentifier, accountId);
        return localVarResp.getData();
    }

    /**
     * Generate Pre Shared Key (PSK) for IPsec tunnels
     * Generates a Pre Shared Key for a specific IPsec tunnel used in the IKE session. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes. After a PSK is generated, the PSK is immediately persisted to Cloudflare&#39;s edge and cannot be retrieved later. Note the PSK in a safe place.
     * @param tunnelIdentifier  (required)
     * @param accountId  (required)
     * @return ApiResponse&lt;MagicPskGenerationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Generate Pre Shared Key (PSK) for IPsec tunnels response </td><td>  -  </td></tr>
        <tr><td> 4xx </td><td> Generate Pre Shared Key (PSK) for IPsec tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MagicPskGenerationResponse> magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsWithHttpInfo(String tunnelIdentifier, String accountId) throws ApiException {
        okhttp3.Call localVarCall = magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsValidateBeforeCall(tunnelIdentifier, accountId, null);
        Type localVarReturnType = new TypeToken<MagicPskGenerationResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Generate Pre Shared Key (PSK) for IPsec tunnels (asynchronously)
     * Generates a Pre Shared Key for a specific IPsec tunnel used in the IKE session. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes. After a PSK is generated, the PSK is immediately persisted to Cloudflare&#39;s edge and cannot be retrieved later. Note the PSK in a safe place.
     * @param tunnelIdentifier  (required)
     * @param accountId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Generate Pre Shared Key (PSK) for IPsec tunnels response </td><td>  -  </td></tr>
        <tr><td> 4xx </td><td> Generate Pre Shared Key (PSK) for IPsec tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsAsync(String tunnelIdentifier, String accountId, final ApiCallback<MagicPskGenerationResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsValidateBeforeCall(tunnelIdentifier, accountId, _callback);
        Type localVarReturnType = new TypeToken<MagicPskGenerationResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for magicIpsecTunnelsListIpsecTunnelDetails
     * @param tunnelIdentifier  (required)
     * @param accountId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List IPsec tunnel details response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List IPsec tunnel details response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call magicIpsecTunnelsListIpsecTunnelDetailsCall(String tunnelIdentifier, String accountId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/magic/ipsec_tunnels/{tunnel_identifier}"
            .replace("{" + "tunnel_identifier" + "}", localVarApiClient.escapeString(tunnelIdentifier.toString()))
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call magicIpsecTunnelsListIpsecTunnelDetailsValidateBeforeCall(String tunnelIdentifier, String accountId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tunnelIdentifier' is set
        if (tunnelIdentifier == null) {
            throw new ApiException("Missing the required parameter 'tunnelIdentifier' when calling magicIpsecTunnelsListIpsecTunnelDetails(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling magicIpsecTunnelsListIpsecTunnelDetails(Async)");
        }

        return magicIpsecTunnelsListIpsecTunnelDetailsCall(tunnelIdentifier, accountId, _callback);

    }

    /**
     * List IPsec tunnel details
     * Lists details for a specific IPsec tunnel.
     * @param tunnelIdentifier  (required)
     * @param accountId  (required)
     * @return MagicSchemasTunnelSingleResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List IPsec tunnel details response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List IPsec tunnel details response failure </td><td>  -  </td></tr>
     </table>
     */
    public MagicSchemasTunnelSingleResponse magicIpsecTunnelsListIpsecTunnelDetails(String tunnelIdentifier, String accountId) throws ApiException {
        ApiResponse<MagicSchemasTunnelSingleResponse> localVarResp = magicIpsecTunnelsListIpsecTunnelDetailsWithHttpInfo(tunnelIdentifier, accountId);
        return localVarResp.getData();
    }

    /**
     * List IPsec tunnel details
     * Lists details for a specific IPsec tunnel.
     * @param tunnelIdentifier  (required)
     * @param accountId  (required)
     * @return ApiResponse&lt;MagicSchemasTunnelSingleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List IPsec tunnel details response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List IPsec tunnel details response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MagicSchemasTunnelSingleResponse> magicIpsecTunnelsListIpsecTunnelDetailsWithHttpInfo(String tunnelIdentifier, String accountId) throws ApiException {
        okhttp3.Call localVarCall = magicIpsecTunnelsListIpsecTunnelDetailsValidateBeforeCall(tunnelIdentifier, accountId, null);
        Type localVarReturnType = new TypeToken<MagicSchemasTunnelSingleResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List IPsec tunnel details (asynchronously)
     * Lists details for a specific IPsec tunnel.
     * @param tunnelIdentifier  (required)
     * @param accountId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List IPsec tunnel details response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List IPsec tunnel details response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call magicIpsecTunnelsListIpsecTunnelDetailsAsync(String tunnelIdentifier, String accountId, final ApiCallback<MagicSchemasTunnelSingleResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = magicIpsecTunnelsListIpsecTunnelDetailsValidateBeforeCall(tunnelIdentifier, accountId, _callback);
        Type localVarReturnType = new TypeToken<MagicSchemasTunnelSingleResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for magicIpsecTunnelsListIpsecTunnels
     * @param accountId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List IPsec tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List IPsec tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call magicIpsecTunnelsListIpsecTunnelsCall(String accountId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/magic/ipsec_tunnels"
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call magicIpsecTunnelsListIpsecTunnelsValidateBeforeCall(String accountId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling magicIpsecTunnelsListIpsecTunnels(Async)");
        }

        return magicIpsecTunnelsListIpsecTunnelsCall(accountId, _callback);

    }

    /**
     * List IPsec tunnels
     * Lists IPsec tunnels associated with an account.
     * @param accountId  (required)
     * @return MagicSchemasTunnelsCollectionResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List IPsec tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List IPsec tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public MagicSchemasTunnelsCollectionResponse magicIpsecTunnelsListIpsecTunnels(String accountId) throws ApiException {
        ApiResponse<MagicSchemasTunnelsCollectionResponse> localVarResp = magicIpsecTunnelsListIpsecTunnelsWithHttpInfo(accountId);
        return localVarResp.getData();
    }

    /**
     * List IPsec tunnels
     * Lists IPsec tunnels associated with an account.
     * @param accountId  (required)
     * @return ApiResponse&lt;MagicSchemasTunnelsCollectionResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List IPsec tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List IPsec tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MagicSchemasTunnelsCollectionResponse> magicIpsecTunnelsListIpsecTunnelsWithHttpInfo(String accountId) throws ApiException {
        okhttp3.Call localVarCall = magicIpsecTunnelsListIpsecTunnelsValidateBeforeCall(accountId, null);
        Type localVarReturnType = new TypeToken<MagicSchemasTunnelsCollectionResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List IPsec tunnels (asynchronously)
     * Lists IPsec tunnels associated with an account.
     * @param accountId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List IPsec tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List IPsec tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call magicIpsecTunnelsListIpsecTunnelsAsync(String accountId, final ApiCallback<MagicSchemasTunnelsCollectionResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = magicIpsecTunnelsListIpsecTunnelsValidateBeforeCall(accountId, _callback);
        Type localVarReturnType = new TypeToken<MagicSchemasTunnelsCollectionResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for magicIpsecTunnelsUpdateIpsecTunnel
     * @param tunnelIdentifier  (required)
     * @param accountId  (required)
     * @param magicSchemasTunnelUpdateRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Update IPsec Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Update IPsec Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call magicIpsecTunnelsUpdateIpsecTunnelCall(String tunnelIdentifier, String accountId, MagicSchemasTunnelUpdateRequest magicSchemasTunnelUpdateRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = magicSchemasTunnelUpdateRequest;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/magic/ipsec_tunnels/{tunnel_identifier}"
            .replace("{" + "tunnel_identifier" + "}", localVarApiClient.escapeString(tunnelIdentifier.toString()))
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call magicIpsecTunnelsUpdateIpsecTunnelValidateBeforeCall(String tunnelIdentifier, String accountId, MagicSchemasTunnelUpdateRequest magicSchemasTunnelUpdateRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tunnelIdentifier' is set
        if (tunnelIdentifier == null) {
            throw new ApiException("Missing the required parameter 'tunnelIdentifier' when calling magicIpsecTunnelsUpdateIpsecTunnel(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling magicIpsecTunnelsUpdateIpsecTunnel(Async)");
        }

        // verify the required parameter 'magicSchemasTunnelUpdateRequest' is set
        if (magicSchemasTunnelUpdateRequest == null) {
            throw new ApiException("Missing the required parameter 'magicSchemasTunnelUpdateRequest' when calling magicIpsecTunnelsUpdateIpsecTunnel(Async)");
        }

        return magicIpsecTunnelsUpdateIpsecTunnelCall(tunnelIdentifier, accountId, magicSchemasTunnelUpdateRequest, _callback);

    }

    /**
     * Update IPsec Tunnel
     * Updates a specific IPsec tunnel associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.
     * @param tunnelIdentifier  (required)
     * @param accountId  (required)
     * @param magicSchemasTunnelUpdateRequest  (required)
     * @return MagicSchemasTunnelModifiedResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Update IPsec Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Update IPsec Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public MagicSchemasTunnelModifiedResponse magicIpsecTunnelsUpdateIpsecTunnel(String tunnelIdentifier, String accountId, MagicSchemasTunnelUpdateRequest magicSchemasTunnelUpdateRequest) throws ApiException {
        ApiResponse<MagicSchemasTunnelModifiedResponse> localVarResp = magicIpsecTunnelsUpdateIpsecTunnelWithHttpInfo(tunnelIdentifier, accountId, magicSchemasTunnelUpdateRequest);
        return localVarResp.getData();
    }

    /**
     * Update IPsec Tunnel
     * Updates a specific IPsec tunnel associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.
     * @param tunnelIdentifier  (required)
     * @param accountId  (required)
     * @param magicSchemasTunnelUpdateRequest  (required)
     * @return ApiResponse&lt;MagicSchemasTunnelModifiedResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Update IPsec Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Update IPsec Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MagicSchemasTunnelModifiedResponse> magicIpsecTunnelsUpdateIpsecTunnelWithHttpInfo(String tunnelIdentifier, String accountId, MagicSchemasTunnelUpdateRequest magicSchemasTunnelUpdateRequest) throws ApiException {
        okhttp3.Call localVarCall = magicIpsecTunnelsUpdateIpsecTunnelValidateBeforeCall(tunnelIdentifier, accountId, magicSchemasTunnelUpdateRequest, null);
        Type localVarReturnType = new TypeToken<MagicSchemasTunnelModifiedResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update IPsec Tunnel (asynchronously)
     * Updates a specific IPsec tunnel associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.
     * @param tunnelIdentifier  (required)
     * @param accountId  (required)
     * @param magicSchemasTunnelUpdateRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Update IPsec Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Update IPsec Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call magicIpsecTunnelsUpdateIpsecTunnelAsync(String tunnelIdentifier, String accountId, MagicSchemasTunnelUpdateRequest magicSchemasTunnelUpdateRequest, final ApiCallback<MagicSchemasTunnelModifiedResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = magicIpsecTunnelsUpdateIpsecTunnelValidateBeforeCall(tunnelIdentifier, accountId, magicSchemasTunnelUpdateRequest, _callback);
        Type localVarReturnType = new TypeToken<MagicSchemasTunnelModifiedResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for magicIpsecTunnelsUpdateMultipleIpsecTunnels
     * @param accountId  (required)
     * @param body  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Update multiple IPsec tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Update multiple IPsec tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call magicIpsecTunnelsUpdateMultipleIpsecTunnelsCall(String accountId, Object body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/magic/ipsec_tunnels"
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call magicIpsecTunnelsUpdateMultipleIpsecTunnelsValidateBeforeCall(String accountId, Object body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling magicIpsecTunnelsUpdateMultipleIpsecTunnels(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling magicIpsecTunnelsUpdateMultipleIpsecTunnels(Async)");
        }

        return magicIpsecTunnelsUpdateMultipleIpsecTunnelsCall(accountId, body, _callback);

    }

    /**
     * Update multiple IPsec tunnels
     * Update multiple IPsec tunnels associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.
     * @param accountId  (required)
     * @param body  (required)
     * @return MagicSchemasModifiedTunnelsCollectionResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Update multiple IPsec tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Update multiple IPsec tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public MagicSchemasModifiedTunnelsCollectionResponse magicIpsecTunnelsUpdateMultipleIpsecTunnels(String accountId, Object body) throws ApiException {
        ApiResponse<MagicSchemasModifiedTunnelsCollectionResponse> localVarResp = magicIpsecTunnelsUpdateMultipleIpsecTunnelsWithHttpInfo(accountId, body);
        return localVarResp.getData();
    }

    /**
     * Update multiple IPsec tunnels
     * Update multiple IPsec tunnels associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.
     * @param accountId  (required)
     * @param body  (required)
     * @return ApiResponse&lt;MagicSchemasModifiedTunnelsCollectionResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Update multiple IPsec tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Update multiple IPsec tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<MagicSchemasModifiedTunnelsCollectionResponse> magicIpsecTunnelsUpdateMultipleIpsecTunnelsWithHttpInfo(String accountId, Object body) throws ApiException {
        okhttp3.Call localVarCall = magicIpsecTunnelsUpdateMultipleIpsecTunnelsValidateBeforeCall(accountId, body, null);
        Type localVarReturnType = new TypeToken<MagicSchemasModifiedTunnelsCollectionResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update multiple IPsec tunnels (asynchronously)
     * Update multiple IPsec tunnels associated with an account. Use &#x60;?validate_only&#x3D;true&#x60; as an optional query parameter to only run validation without persisting changes.
     * @param accountId  (required)
     * @param body  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Update multiple IPsec tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Update multiple IPsec tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call magicIpsecTunnelsUpdateMultipleIpsecTunnelsAsync(String accountId, Object body, final ApiCallback<MagicSchemasModifiedTunnelsCollectionResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = magicIpsecTunnelsUpdateMultipleIpsecTunnelsValidateBeforeCall(accountId, body, _callback);
        Type localVarReturnType = new TypeToken<MagicSchemasModifiedTunnelsCollectionResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
