/*
 * Cloudflare API
 * To get started using Cloudflare's products and services via the API, refer to [how to interact with Cloudflare](https://developers.cloudflare.com/fundamentals/basic-tasks/interact-with-cloudflare/), which covers using tools like [Terraform](https://developers.cloudflare.com/terraform/#cloudflare-terraform) and the [official SDKs](https://developers.cloudflare.com/fundamentals/api/reference/sdks/) to maintain your Cloudflare resources.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * The version of the OpenAPI document: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package cloudflare.sdk;

import cloudflare.ApiClient;
import cloudflare.ApiException;
import cloudflare.ApiResponse;
import cloudflare.Pair;

import java.math.BigDecimal;
import cloudflare.sdk.models.CreateCustomHostname4XXResponse;
import cloudflare.sdk.models.CreateCustomHostnameRequest;
import cloudflare.sdk.models.CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificates200Response;
import cloudflare.sdk.models.CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificates4XXResponse;
import cloudflare.sdk.models.ListCustomHostnames4XXResponse;
import cloudflare.sdk.models.TlsCertificatesAndHostnamesCustomHostnameResponseCollection;
import cloudflare.sdk.models.TlsCertificatesAndHostnamesCustomHostnameResponseSingle;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-05-21T10:12:24.693742223+01:00[Europe/London]", comments = "Generator version: 7.5.0")
public class CustomHostnameForAZoneApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public CustomHostnameForAZoneApi() {
    this(new ApiClient());
  }

  public CustomHostnameForAZoneApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Create Custom Hostname
   * Add a new custom hostname and request that an SSL certificate be issued for it. One of three validation methods—http, txt, email—should be used, with &#39;http&#39; recommended if the CNAME is already in place (or will be soon). Specifying &#39;email&#39; will send an email to the WHOIS contacts on file for the base domain plus hostmaster, postmaster, webmaster, admin, administrator. If http is used and the domain is not already pointing to the Managed CNAME host, the PATCH method must be used once it is (to complete validation).
   * @param zoneId  (required)
   * @param createCustomHostnameRequest  (required)
   * @return TlsCertificatesAndHostnamesCustomHostnameResponseSingle
   * @throws ApiException if fails to make API call
   */
  public TlsCertificatesAndHostnamesCustomHostnameResponseSingle createCustomHostname(String zoneId, CreateCustomHostnameRequest createCustomHostnameRequest) throws ApiException {
    ApiResponse<TlsCertificatesAndHostnamesCustomHostnameResponseSingle> localVarResponse = createCustomHostnameWithHttpInfo(zoneId, createCustomHostnameRequest);
    return localVarResponse.getData();
  }

  /**
   * Create Custom Hostname
   * Add a new custom hostname and request that an SSL certificate be issued for it. One of three validation methods—http, txt, email—should be used, with &#39;http&#39; recommended if the CNAME is already in place (or will be soon). Specifying &#39;email&#39; will send an email to the WHOIS contacts on file for the base domain plus hostmaster, postmaster, webmaster, admin, administrator. If http is used and the domain is not already pointing to the Managed CNAME host, the PATCH method must be used once it is (to complete validation).
   * @param zoneId  (required)
   * @param createCustomHostnameRequest  (required)
   * @return ApiResponse&lt;TlsCertificatesAndHostnamesCustomHostnameResponseSingle&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<TlsCertificatesAndHostnamesCustomHostnameResponseSingle> createCustomHostnameWithHttpInfo(String zoneId, CreateCustomHostnameRequest createCustomHostnameRequest) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = createCustomHostnameRequestBuilder(zoneId, createCustomHostnameRequest);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("createCustomHostname", localVarResponse);
        }
        return new ApiResponse<TlsCertificatesAndHostnamesCustomHostnameResponseSingle>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<TlsCertificatesAndHostnamesCustomHostnameResponseSingle>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder createCustomHostnameRequestBuilder(String zoneId, CreateCustomHostnameRequest createCustomHostnameRequest) throws ApiException {
    // verify the required parameter 'zoneId' is set
    if (zoneId == null) {
      throw new ApiException(400, "Missing the required parameter 'zoneId' when calling createCustomHostname");
    }
    // verify the required parameter 'createCustomHostnameRequest' is set
    if (createCustomHostnameRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'createCustomHostnameRequest' when calling createCustomHostname");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/zones/{zone_id}/custom_hostnames"
        .replace("{zone_id}", ApiClient.urlEncode(zoneId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(createCustomHostnameRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Delete Custom Hostname (and any issued SSL certificates)
   * 
   * @param customHostnameId  (required)
   * @param zoneId  (required)
   * @return CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificates200Response
   * @throws ApiException if fails to make API call
   */
  public CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificates200Response customHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificates(String customHostnameId, String zoneId) throws ApiException {
    ApiResponse<CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificates200Response> localVarResponse = customHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificatesWithHttpInfo(customHostnameId, zoneId);
    return localVarResponse.getData();
  }

  /**
   * Delete Custom Hostname (and any issued SSL certificates)
   * 
   * @param customHostnameId  (required)
   * @param zoneId  (required)
   * @return ApiResponse&lt;CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificates200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificates200Response> customHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificatesWithHttpInfo(String customHostnameId, String zoneId) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = customHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificatesRequestBuilder(customHostnameId, zoneId);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("customHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificates", localVarResponse);
        }
        return new ApiResponse<CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificates200Response>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificates200Response>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder customHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificatesRequestBuilder(String customHostnameId, String zoneId) throws ApiException {
    // verify the required parameter 'customHostnameId' is set
    if (customHostnameId == null) {
      throw new ApiException(400, "Missing the required parameter 'customHostnameId' when calling customHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificates");
    }
    // verify the required parameter 'zoneId' is set
    if (zoneId == null) {
      throw new ApiException(400, "Missing the required parameter 'zoneId' when calling customHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificates");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/zones/{zone_id}/custom_hostnames/{custom_hostname_id}"
        .replace("{custom_hostname_id}", ApiClient.urlEncode(customHostnameId.toString()))
        .replace("{zone_id}", ApiClient.urlEncode(zoneId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List Custom Hostnames
   * List, search, sort, and filter all of your custom hostnames.
   * @param zoneId  (required)
   * @param hostname  (optional)
   * @param id  (optional)
   * @param page  (optional, default to 1)
   * @param perPage  (optional, default to 20)
   * @param order  (optional, default to ssl)
   * @param direction  (optional)
   * @param ssl  (optional)
   * @return TlsCertificatesAndHostnamesCustomHostnameResponseCollection
   * @throws ApiException if fails to make API call
   */
  public TlsCertificatesAndHostnamesCustomHostnameResponseCollection listCustomHostnames(String zoneId, String hostname, String id, BigDecimal page, BigDecimal perPage, String order, String direction, BigDecimal ssl) throws ApiException {
    ApiResponse<TlsCertificatesAndHostnamesCustomHostnameResponseCollection> localVarResponse = listCustomHostnamesWithHttpInfo(zoneId, hostname, id, page, perPage, order, direction, ssl);
    return localVarResponse.getData();
  }

  /**
   * List Custom Hostnames
   * List, search, sort, and filter all of your custom hostnames.
   * @param zoneId  (required)
   * @param hostname  (optional)
   * @param id  (optional)
   * @param page  (optional, default to 1)
   * @param perPage  (optional, default to 20)
   * @param order  (optional, default to ssl)
   * @param direction  (optional)
   * @param ssl  (optional)
   * @return ApiResponse&lt;TlsCertificatesAndHostnamesCustomHostnameResponseCollection&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<TlsCertificatesAndHostnamesCustomHostnameResponseCollection> listCustomHostnamesWithHttpInfo(String zoneId, String hostname, String id, BigDecimal page, BigDecimal perPage, String order, String direction, BigDecimal ssl) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = listCustomHostnamesRequestBuilder(zoneId, hostname, id, page, perPage, order, direction, ssl);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("listCustomHostnames", localVarResponse);
        }
        return new ApiResponse<TlsCertificatesAndHostnamesCustomHostnameResponseCollection>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          localVarResponse.body() == null ? null : memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<TlsCertificatesAndHostnamesCustomHostnameResponseCollection>() {}) // closes the InputStream
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder listCustomHostnamesRequestBuilder(String zoneId, String hostname, String id, BigDecimal page, BigDecimal perPage, String order, String direction, BigDecimal ssl) throws ApiException {
    // verify the required parameter 'zoneId' is set
    if (zoneId == null) {
      throw new ApiException(400, "Missing the required parameter 'zoneId' when calling listCustomHostnames");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/zones/{zone_id}/custom_hostnames"
        .replace("{zone_id}", ApiClient.urlEncode(zoneId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "hostname";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("hostname", hostname));
    localVarQueryParameterBaseName = "id";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("id", id));
    localVarQueryParameterBaseName = "page";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("page", page));
    localVarQueryParameterBaseName = "per_page";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("per_page", perPage));
    localVarQueryParameterBaseName = "order";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("order", order));
    localVarQueryParameterBaseName = "direction";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("direction", direction));
    localVarQueryParameterBaseName = "ssl";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("ssl", ssl));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

}
