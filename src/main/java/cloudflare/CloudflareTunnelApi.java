/*
 * Cloudflare API
 * To get started using Cloudflare's products and services via the API, refer to [how to interact with Cloudflare](https://developers.cloudflare.com/fundamentals/basic-tasks/interact-with-cloudflare/), which covers using tools like [Terraform](https://developers.cloudflare.com/terraform/#cloudflare-terraform) and the [official SDKs](https://developers.cloudflare.com/fundamentals/api/reference/sdks/) to maintain your Cloudflare resources.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * The version of the OpenAPI document: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package cloudflare;

import invalidPackageName.ApiCallback;
import invalidPackageName.ApiClient;
import invalidPackageName.ApiException;
import invalidPackageName.ApiResponse;
import invalidPackageName.Configuration;
import invalidPackageName.Pair;
import invalidPackageName.ProgressRequestBody;
import invalidPackageName.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.math.BigDecimal;
import org.openapitools.client.model.CloudflareTunnelCleanUpCloudflareTunnelConnections4XXResponse;
import org.openapitools.client.model.CloudflareTunnelCreateACloudflareTunnel4XXResponse;
import org.openapitools.client.model.CloudflareTunnelCreateACloudflareTunnelRequest;
import org.openapitools.client.model.CloudflareTunnelCreateAWarpConnectorTunnelRequest;
import org.openapitools.client.model.CloudflareTunnelGetACloudflareTunnelManagementToken4XXResponse;
import org.openapitools.client.model.CloudflareTunnelGetACloudflareTunnelManagementTokenRequest;
import org.openapitools.client.model.CloudflareTunnelGetCloudflareTunnelConnector4XXResponse;
import org.openapitools.client.model.CloudflareTunnelListCloudflareTunnelConnections4XXResponse;
import org.openapitools.client.model.CloudflareTunnelListCloudflareTunnels4XXResponse;
import org.openapitools.client.model.CloudflareTunnelUpdateACloudflareTunnelRequest;
import java.time.OffsetDateTime;
import org.openapitools.client.model.TunnelEmptyResponse;
import org.openapitools.client.model.TunnelTunnelClientResponse;
import org.openapitools.client.model.TunnelTunnelConnectionsResponse;
import org.openapitools.client.model.TunnelTunnelResponseCollection;
import org.openapitools.client.model.TunnelTunnelResponseSingle;
import org.openapitools.client.model.TunnelTunnelResponseToken;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class CloudflareTunnelApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public CloudflareTunnelApi() {
        this(Configuration.getDefaultApiClient());
    }

    public CloudflareTunnelApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for cloudflareTunnelCleanUpCloudflareTunnelConnections
     * @param accountId  (required)
     * @param tunnelId  (required)
     * @param body  (required)
     * @param clientId  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Clean up Cloudflare Tunnel connections response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Clean up Cloudflare Tunnel connections response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelCleanUpCloudflareTunnelConnectionsCall(String accountId, String tunnelId, Object body, String clientId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/cfd_tunnel/{tunnel_id}/connections"
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()))
            .replace("{" + "tunnel_id" + "}", localVarApiClient.escapeString(tunnelId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (clientId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("client_id", clientId));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cloudflareTunnelCleanUpCloudflareTunnelConnectionsValidateBeforeCall(String accountId, String tunnelId, Object body, String clientId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cloudflareTunnelCleanUpCloudflareTunnelConnections(Async)");
        }

        // verify the required parameter 'tunnelId' is set
        if (tunnelId == null) {
            throw new ApiException("Missing the required parameter 'tunnelId' when calling cloudflareTunnelCleanUpCloudflareTunnelConnections(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling cloudflareTunnelCleanUpCloudflareTunnelConnections(Async)");
        }

        return cloudflareTunnelCleanUpCloudflareTunnelConnectionsCall(accountId, tunnelId, body, clientId, _callback);

    }

    /**
     * Clean up Cloudflare Tunnel connections
     * Removes a connection (aka Cloudflare Tunnel Connector) from a Cloudflare Tunnel independently of its current state. If no connector id (client_id) is provided all connectors will be removed. We recommend running this command after rotating tokens.
     * @param accountId  (required)
     * @param tunnelId  (required)
     * @param body  (required)
     * @param clientId  (optional)
     * @return TunnelEmptyResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Clean up Cloudflare Tunnel connections response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Clean up Cloudflare Tunnel connections response failure </td><td>  -  </td></tr>
     </table>
     */
    public TunnelEmptyResponse cloudflareTunnelCleanUpCloudflareTunnelConnections(String accountId, String tunnelId, Object body, String clientId) throws ApiException {
        ApiResponse<TunnelEmptyResponse> localVarResp = cloudflareTunnelCleanUpCloudflareTunnelConnectionsWithHttpInfo(accountId, tunnelId, body, clientId);
        return localVarResp.getData();
    }

    /**
     * Clean up Cloudflare Tunnel connections
     * Removes a connection (aka Cloudflare Tunnel Connector) from a Cloudflare Tunnel independently of its current state. If no connector id (client_id) is provided all connectors will be removed. We recommend running this command after rotating tokens.
     * @param accountId  (required)
     * @param tunnelId  (required)
     * @param body  (required)
     * @param clientId  (optional)
     * @return ApiResponse&lt;TunnelEmptyResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Clean up Cloudflare Tunnel connections response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Clean up Cloudflare Tunnel connections response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TunnelEmptyResponse> cloudflareTunnelCleanUpCloudflareTunnelConnectionsWithHttpInfo(String accountId, String tunnelId, Object body, String clientId) throws ApiException {
        okhttp3.Call localVarCall = cloudflareTunnelCleanUpCloudflareTunnelConnectionsValidateBeforeCall(accountId, tunnelId, body, clientId, null);
        Type localVarReturnType = new TypeToken<TunnelEmptyResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Clean up Cloudflare Tunnel connections (asynchronously)
     * Removes a connection (aka Cloudflare Tunnel Connector) from a Cloudflare Tunnel independently of its current state. If no connector id (client_id) is provided all connectors will be removed. We recommend running this command after rotating tokens.
     * @param accountId  (required)
     * @param tunnelId  (required)
     * @param body  (required)
     * @param clientId  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Clean up Cloudflare Tunnel connections response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Clean up Cloudflare Tunnel connections response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelCleanUpCloudflareTunnelConnectionsAsync(String accountId, String tunnelId, Object body, String clientId, final ApiCallback<TunnelEmptyResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = cloudflareTunnelCleanUpCloudflareTunnelConnectionsValidateBeforeCall(accountId, tunnelId, body, clientId, _callback);
        Type localVarReturnType = new TypeToken<TunnelEmptyResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for cloudflareTunnelCreateACloudflareTunnel
     * @param accountId  (required)
     * @param cloudflareTunnelCreateACloudflareTunnelRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Create a Cloudflare Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Create a Cloudflare Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelCreateACloudflareTunnelCall(String accountId, CloudflareTunnelCreateACloudflareTunnelRequest cloudflareTunnelCreateACloudflareTunnelRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = cloudflareTunnelCreateACloudflareTunnelRequest;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/cfd_tunnel"
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cloudflareTunnelCreateACloudflareTunnelValidateBeforeCall(String accountId, CloudflareTunnelCreateACloudflareTunnelRequest cloudflareTunnelCreateACloudflareTunnelRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cloudflareTunnelCreateACloudflareTunnel(Async)");
        }

        // verify the required parameter 'cloudflareTunnelCreateACloudflareTunnelRequest' is set
        if (cloudflareTunnelCreateACloudflareTunnelRequest == null) {
            throw new ApiException("Missing the required parameter 'cloudflareTunnelCreateACloudflareTunnelRequest' when calling cloudflareTunnelCreateACloudflareTunnel(Async)");
        }

        return cloudflareTunnelCreateACloudflareTunnelCall(accountId, cloudflareTunnelCreateACloudflareTunnelRequest, _callback);

    }

    /**
     * Create a Cloudflare Tunnel
     * Creates a new Cloudflare Tunnel in an account.
     * @param accountId  (required)
     * @param cloudflareTunnelCreateACloudflareTunnelRequest  (required)
     * @return TunnelTunnelResponseSingle
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Create a Cloudflare Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Create a Cloudflare Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public TunnelTunnelResponseSingle cloudflareTunnelCreateACloudflareTunnel(String accountId, CloudflareTunnelCreateACloudflareTunnelRequest cloudflareTunnelCreateACloudflareTunnelRequest) throws ApiException {
        ApiResponse<TunnelTunnelResponseSingle> localVarResp = cloudflareTunnelCreateACloudflareTunnelWithHttpInfo(accountId, cloudflareTunnelCreateACloudflareTunnelRequest);
        return localVarResp.getData();
    }

    /**
     * Create a Cloudflare Tunnel
     * Creates a new Cloudflare Tunnel in an account.
     * @param accountId  (required)
     * @param cloudflareTunnelCreateACloudflareTunnelRequest  (required)
     * @return ApiResponse&lt;TunnelTunnelResponseSingle&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Create a Cloudflare Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Create a Cloudflare Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TunnelTunnelResponseSingle> cloudflareTunnelCreateACloudflareTunnelWithHttpInfo(String accountId, CloudflareTunnelCreateACloudflareTunnelRequest cloudflareTunnelCreateACloudflareTunnelRequest) throws ApiException {
        okhttp3.Call localVarCall = cloudflareTunnelCreateACloudflareTunnelValidateBeforeCall(accountId, cloudflareTunnelCreateACloudflareTunnelRequest, null);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseSingle>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a Cloudflare Tunnel (asynchronously)
     * Creates a new Cloudflare Tunnel in an account.
     * @param accountId  (required)
     * @param cloudflareTunnelCreateACloudflareTunnelRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Create a Cloudflare Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Create a Cloudflare Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelCreateACloudflareTunnelAsync(String accountId, CloudflareTunnelCreateACloudflareTunnelRequest cloudflareTunnelCreateACloudflareTunnelRequest, final ApiCallback<TunnelTunnelResponseSingle> _callback) throws ApiException {

        okhttp3.Call localVarCall = cloudflareTunnelCreateACloudflareTunnelValidateBeforeCall(accountId, cloudflareTunnelCreateACloudflareTunnelRequest, _callback);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseSingle>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for cloudflareTunnelCreateAWarpConnectorTunnel
     * @param accountId  (required)
     * @param cloudflareTunnelCreateAWarpConnectorTunnelRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Create a Warp Connector Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Create a Warp Connector Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelCreateAWarpConnectorTunnelCall(String accountId, CloudflareTunnelCreateAWarpConnectorTunnelRequest cloudflareTunnelCreateAWarpConnectorTunnelRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = cloudflareTunnelCreateAWarpConnectorTunnelRequest;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/warp_connector"
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cloudflareTunnelCreateAWarpConnectorTunnelValidateBeforeCall(String accountId, CloudflareTunnelCreateAWarpConnectorTunnelRequest cloudflareTunnelCreateAWarpConnectorTunnelRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cloudflareTunnelCreateAWarpConnectorTunnel(Async)");
        }

        // verify the required parameter 'cloudflareTunnelCreateAWarpConnectorTunnelRequest' is set
        if (cloudflareTunnelCreateAWarpConnectorTunnelRequest == null) {
            throw new ApiException("Missing the required parameter 'cloudflareTunnelCreateAWarpConnectorTunnelRequest' when calling cloudflareTunnelCreateAWarpConnectorTunnel(Async)");
        }

        return cloudflareTunnelCreateAWarpConnectorTunnelCall(accountId, cloudflareTunnelCreateAWarpConnectorTunnelRequest, _callback);

    }

    /**
     * Create a Warp Connector Tunnel
     * Creates a new Warp Connector Tunnel in an account.
     * @param accountId  (required)
     * @param cloudflareTunnelCreateAWarpConnectorTunnelRequest  (required)
     * @return TunnelTunnelResponseSingle
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Create a Warp Connector Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Create a Warp Connector Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public TunnelTunnelResponseSingle cloudflareTunnelCreateAWarpConnectorTunnel(String accountId, CloudflareTunnelCreateAWarpConnectorTunnelRequest cloudflareTunnelCreateAWarpConnectorTunnelRequest) throws ApiException {
        ApiResponse<TunnelTunnelResponseSingle> localVarResp = cloudflareTunnelCreateAWarpConnectorTunnelWithHttpInfo(accountId, cloudflareTunnelCreateAWarpConnectorTunnelRequest);
        return localVarResp.getData();
    }

    /**
     * Create a Warp Connector Tunnel
     * Creates a new Warp Connector Tunnel in an account.
     * @param accountId  (required)
     * @param cloudflareTunnelCreateAWarpConnectorTunnelRequest  (required)
     * @return ApiResponse&lt;TunnelTunnelResponseSingle&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Create a Warp Connector Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Create a Warp Connector Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TunnelTunnelResponseSingle> cloudflareTunnelCreateAWarpConnectorTunnelWithHttpInfo(String accountId, CloudflareTunnelCreateAWarpConnectorTunnelRequest cloudflareTunnelCreateAWarpConnectorTunnelRequest) throws ApiException {
        okhttp3.Call localVarCall = cloudflareTunnelCreateAWarpConnectorTunnelValidateBeforeCall(accountId, cloudflareTunnelCreateAWarpConnectorTunnelRequest, null);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseSingle>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a Warp Connector Tunnel (asynchronously)
     * Creates a new Warp Connector Tunnel in an account.
     * @param accountId  (required)
     * @param cloudflareTunnelCreateAWarpConnectorTunnelRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Create a Warp Connector Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Create a Warp Connector Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelCreateAWarpConnectorTunnelAsync(String accountId, CloudflareTunnelCreateAWarpConnectorTunnelRequest cloudflareTunnelCreateAWarpConnectorTunnelRequest, final ApiCallback<TunnelTunnelResponseSingle> _callback) throws ApiException {

        okhttp3.Call localVarCall = cloudflareTunnelCreateAWarpConnectorTunnelValidateBeforeCall(accountId, cloudflareTunnelCreateAWarpConnectorTunnelRequest, _callback);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseSingle>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for cloudflareTunnelDeleteACloudflareTunnel
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param body  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Delete a Cloudflare Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Delete a Cloudflare Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelDeleteACloudflareTunnelCall(String tunnelId, String accountId, Object body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/cfd_tunnel/{tunnel_id}"
            .replace("{" + "tunnel_id" + "}", localVarApiClient.escapeString(tunnelId.toString()))
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cloudflareTunnelDeleteACloudflareTunnelValidateBeforeCall(String tunnelId, String accountId, Object body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tunnelId' is set
        if (tunnelId == null) {
            throw new ApiException("Missing the required parameter 'tunnelId' when calling cloudflareTunnelDeleteACloudflareTunnel(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cloudflareTunnelDeleteACloudflareTunnel(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling cloudflareTunnelDeleteACloudflareTunnel(Async)");
        }

        return cloudflareTunnelDeleteACloudflareTunnelCall(tunnelId, accountId, body, _callback);

    }

    /**
     * Delete a Cloudflare Tunnel
     * Deletes a Cloudflare Tunnel from an account.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param body  (required)
     * @return TunnelTunnelResponseSingle
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Delete a Cloudflare Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Delete a Cloudflare Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public TunnelTunnelResponseSingle cloudflareTunnelDeleteACloudflareTunnel(String tunnelId, String accountId, Object body) throws ApiException {
        ApiResponse<TunnelTunnelResponseSingle> localVarResp = cloudflareTunnelDeleteACloudflareTunnelWithHttpInfo(tunnelId, accountId, body);
        return localVarResp.getData();
    }

    /**
     * Delete a Cloudflare Tunnel
     * Deletes a Cloudflare Tunnel from an account.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param body  (required)
     * @return ApiResponse&lt;TunnelTunnelResponseSingle&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Delete a Cloudflare Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Delete a Cloudflare Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TunnelTunnelResponseSingle> cloudflareTunnelDeleteACloudflareTunnelWithHttpInfo(String tunnelId, String accountId, Object body) throws ApiException {
        okhttp3.Call localVarCall = cloudflareTunnelDeleteACloudflareTunnelValidateBeforeCall(tunnelId, accountId, body, null);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseSingle>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete a Cloudflare Tunnel (asynchronously)
     * Deletes a Cloudflare Tunnel from an account.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param body  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Delete a Cloudflare Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Delete a Cloudflare Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelDeleteACloudflareTunnelAsync(String tunnelId, String accountId, Object body, final ApiCallback<TunnelTunnelResponseSingle> _callback) throws ApiException {

        okhttp3.Call localVarCall = cloudflareTunnelDeleteACloudflareTunnelValidateBeforeCall(tunnelId, accountId, body, _callback);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseSingle>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for cloudflareTunnelDeleteAWarpConnectorTunnel
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param body  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Delete a Warp Connector Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Delete a Warp Connector Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelDeleteAWarpConnectorTunnelCall(String tunnelId, String accountId, Object body, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = body;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/warp_connector/{tunnel_id}"
            .replace("{" + "tunnel_id" + "}", localVarApiClient.escapeString(tunnelId.toString()))
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cloudflareTunnelDeleteAWarpConnectorTunnelValidateBeforeCall(String tunnelId, String accountId, Object body, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tunnelId' is set
        if (tunnelId == null) {
            throw new ApiException("Missing the required parameter 'tunnelId' when calling cloudflareTunnelDeleteAWarpConnectorTunnel(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cloudflareTunnelDeleteAWarpConnectorTunnel(Async)");
        }

        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling cloudflareTunnelDeleteAWarpConnectorTunnel(Async)");
        }

        return cloudflareTunnelDeleteAWarpConnectorTunnelCall(tunnelId, accountId, body, _callback);

    }

    /**
     * Delete a Warp Connector Tunnel
     * Deletes a Warp Connector Tunnel from an account.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param body  (required)
     * @return TunnelTunnelResponseSingle
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Delete a Warp Connector Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Delete a Warp Connector Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public TunnelTunnelResponseSingle cloudflareTunnelDeleteAWarpConnectorTunnel(String tunnelId, String accountId, Object body) throws ApiException {
        ApiResponse<TunnelTunnelResponseSingle> localVarResp = cloudflareTunnelDeleteAWarpConnectorTunnelWithHttpInfo(tunnelId, accountId, body);
        return localVarResp.getData();
    }

    /**
     * Delete a Warp Connector Tunnel
     * Deletes a Warp Connector Tunnel from an account.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param body  (required)
     * @return ApiResponse&lt;TunnelTunnelResponseSingle&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Delete a Warp Connector Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Delete a Warp Connector Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TunnelTunnelResponseSingle> cloudflareTunnelDeleteAWarpConnectorTunnelWithHttpInfo(String tunnelId, String accountId, Object body) throws ApiException {
        okhttp3.Call localVarCall = cloudflareTunnelDeleteAWarpConnectorTunnelValidateBeforeCall(tunnelId, accountId, body, null);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseSingle>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete a Warp Connector Tunnel (asynchronously)
     * Deletes a Warp Connector Tunnel from an account.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param body  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Delete a Warp Connector Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Delete a Warp Connector Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelDeleteAWarpConnectorTunnelAsync(String tunnelId, String accountId, Object body, final ApiCallback<TunnelTunnelResponseSingle> _callback) throws ApiException {

        okhttp3.Call localVarCall = cloudflareTunnelDeleteAWarpConnectorTunnelValidateBeforeCall(tunnelId, accountId, body, _callback);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseSingle>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for cloudflareTunnelGetACloudflareTunnel
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Cloudflare Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get a Cloudflare Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelGetACloudflareTunnelCall(String tunnelId, String accountId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/cfd_tunnel/{tunnel_id}"
            .replace("{" + "tunnel_id" + "}", localVarApiClient.escapeString(tunnelId.toString()))
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cloudflareTunnelGetACloudflareTunnelValidateBeforeCall(String tunnelId, String accountId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tunnelId' is set
        if (tunnelId == null) {
            throw new ApiException("Missing the required parameter 'tunnelId' when calling cloudflareTunnelGetACloudflareTunnel(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cloudflareTunnelGetACloudflareTunnel(Async)");
        }

        return cloudflareTunnelGetACloudflareTunnelCall(tunnelId, accountId, _callback);

    }

    /**
     * Get a Cloudflare Tunnel
     * Fetches a single Cloudflare Tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @return TunnelTunnelResponseSingle
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Cloudflare Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get a Cloudflare Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public TunnelTunnelResponseSingle cloudflareTunnelGetACloudflareTunnel(String tunnelId, String accountId) throws ApiException {
        ApiResponse<TunnelTunnelResponseSingle> localVarResp = cloudflareTunnelGetACloudflareTunnelWithHttpInfo(tunnelId, accountId);
        return localVarResp.getData();
    }

    /**
     * Get a Cloudflare Tunnel
     * Fetches a single Cloudflare Tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @return ApiResponse&lt;TunnelTunnelResponseSingle&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Cloudflare Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get a Cloudflare Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TunnelTunnelResponseSingle> cloudflareTunnelGetACloudflareTunnelWithHttpInfo(String tunnelId, String accountId) throws ApiException {
        okhttp3.Call localVarCall = cloudflareTunnelGetACloudflareTunnelValidateBeforeCall(tunnelId, accountId, null);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseSingle>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a Cloudflare Tunnel (asynchronously)
     * Fetches a single Cloudflare Tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Cloudflare Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get a Cloudflare Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelGetACloudflareTunnelAsync(String tunnelId, String accountId, final ApiCallback<TunnelTunnelResponseSingle> _callback) throws ApiException {

        okhttp3.Call localVarCall = cloudflareTunnelGetACloudflareTunnelValidateBeforeCall(tunnelId, accountId, _callback);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseSingle>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for cloudflareTunnelGetACloudflareTunnelManagementToken
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param cloudflareTunnelGetACloudflareTunnelManagementTokenRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Cloudflare Tunnel management token response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Cloudflare API response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelGetACloudflareTunnelManagementTokenCall(String tunnelId, String accountId, CloudflareTunnelGetACloudflareTunnelManagementTokenRequest cloudflareTunnelGetACloudflareTunnelManagementTokenRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = cloudflareTunnelGetACloudflareTunnelManagementTokenRequest;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/cfd_tunnel/{tunnel_id}/management"
            .replace("{" + "tunnel_id" + "}", localVarApiClient.escapeString(tunnelId.toString()))
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cloudflareTunnelGetACloudflareTunnelManagementTokenValidateBeforeCall(String tunnelId, String accountId, CloudflareTunnelGetACloudflareTunnelManagementTokenRequest cloudflareTunnelGetACloudflareTunnelManagementTokenRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tunnelId' is set
        if (tunnelId == null) {
            throw new ApiException("Missing the required parameter 'tunnelId' when calling cloudflareTunnelGetACloudflareTunnelManagementToken(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cloudflareTunnelGetACloudflareTunnelManagementToken(Async)");
        }

        // verify the required parameter 'cloudflareTunnelGetACloudflareTunnelManagementTokenRequest' is set
        if (cloudflareTunnelGetACloudflareTunnelManagementTokenRequest == null) {
            throw new ApiException("Missing the required parameter 'cloudflareTunnelGetACloudflareTunnelManagementTokenRequest' when calling cloudflareTunnelGetACloudflareTunnelManagementToken(Async)");
        }

        return cloudflareTunnelGetACloudflareTunnelManagementTokenCall(tunnelId, accountId, cloudflareTunnelGetACloudflareTunnelManagementTokenRequest, _callback);

    }

    /**
     * Get a Cloudflare Tunnel management token
     * Gets a management token used to access the management resources (i.e. Streaming Logs) of a tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param cloudflareTunnelGetACloudflareTunnelManagementTokenRequest  (required)
     * @return TunnelTunnelResponseToken
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Cloudflare Tunnel management token response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Cloudflare API response failure </td><td>  -  </td></tr>
     </table>
     */
    public TunnelTunnelResponseToken cloudflareTunnelGetACloudflareTunnelManagementToken(String tunnelId, String accountId, CloudflareTunnelGetACloudflareTunnelManagementTokenRequest cloudflareTunnelGetACloudflareTunnelManagementTokenRequest) throws ApiException {
        ApiResponse<TunnelTunnelResponseToken> localVarResp = cloudflareTunnelGetACloudflareTunnelManagementTokenWithHttpInfo(tunnelId, accountId, cloudflareTunnelGetACloudflareTunnelManagementTokenRequest);
        return localVarResp.getData();
    }

    /**
     * Get a Cloudflare Tunnel management token
     * Gets a management token used to access the management resources (i.e. Streaming Logs) of a tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param cloudflareTunnelGetACloudflareTunnelManagementTokenRequest  (required)
     * @return ApiResponse&lt;TunnelTunnelResponseToken&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Cloudflare Tunnel management token response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Cloudflare API response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TunnelTunnelResponseToken> cloudflareTunnelGetACloudflareTunnelManagementTokenWithHttpInfo(String tunnelId, String accountId, CloudflareTunnelGetACloudflareTunnelManagementTokenRequest cloudflareTunnelGetACloudflareTunnelManagementTokenRequest) throws ApiException {
        okhttp3.Call localVarCall = cloudflareTunnelGetACloudflareTunnelManagementTokenValidateBeforeCall(tunnelId, accountId, cloudflareTunnelGetACloudflareTunnelManagementTokenRequest, null);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseToken>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a Cloudflare Tunnel management token (asynchronously)
     * Gets a management token used to access the management resources (i.e. Streaming Logs) of a tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param cloudflareTunnelGetACloudflareTunnelManagementTokenRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Cloudflare Tunnel management token response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Cloudflare API response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelGetACloudflareTunnelManagementTokenAsync(String tunnelId, String accountId, CloudflareTunnelGetACloudflareTunnelManagementTokenRequest cloudflareTunnelGetACloudflareTunnelManagementTokenRequest, final ApiCallback<TunnelTunnelResponseToken> _callback) throws ApiException {

        okhttp3.Call localVarCall = cloudflareTunnelGetACloudflareTunnelManagementTokenValidateBeforeCall(tunnelId, accountId, cloudflareTunnelGetACloudflareTunnelManagementTokenRequest, _callback);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseToken>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for cloudflareTunnelGetACloudflareTunnelToken
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Cloudflare Tunnel token response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get a Cloudflare Tunnel token response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelGetACloudflareTunnelTokenCall(String tunnelId, String accountId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/cfd_tunnel/{tunnel_id}/token"
            .replace("{" + "tunnel_id" + "}", localVarApiClient.escapeString(tunnelId.toString()))
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cloudflareTunnelGetACloudflareTunnelTokenValidateBeforeCall(String tunnelId, String accountId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tunnelId' is set
        if (tunnelId == null) {
            throw new ApiException("Missing the required parameter 'tunnelId' when calling cloudflareTunnelGetACloudflareTunnelToken(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cloudflareTunnelGetACloudflareTunnelToken(Async)");
        }

        return cloudflareTunnelGetACloudflareTunnelTokenCall(tunnelId, accountId, _callback);

    }

    /**
     * Get a Cloudflare Tunnel token
     * Gets the token used to associate cloudflared with a specific tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @return TunnelTunnelResponseToken
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Cloudflare Tunnel token response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get a Cloudflare Tunnel token response failure </td><td>  -  </td></tr>
     </table>
     */
    public TunnelTunnelResponseToken cloudflareTunnelGetACloudflareTunnelToken(String tunnelId, String accountId) throws ApiException {
        ApiResponse<TunnelTunnelResponseToken> localVarResp = cloudflareTunnelGetACloudflareTunnelTokenWithHttpInfo(tunnelId, accountId);
        return localVarResp.getData();
    }

    /**
     * Get a Cloudflare Tunnel token
     * Gets the token used to associate cloudflared with a specific tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @return ApiResponse&lt;TunnelTunnelResponseToken&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Cloudflare Tunnel token response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get a Cloudflare Tunnel token response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TunnelTunnelResponseToken> cloudflareTunnelGetACloudflareTunnelTokenWithHttpInfo(String tunnelId, String accountId) throws ApiException {
        okhttp3.Call localVarCall = cloudflareTunnelGetACloudflareTunnelTokenValidateBeforeCall(tunnelId, accountId, null);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseToken>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a Cloudflare Tunnel token (asynchronously)
     * Gets the token used to associate cloudflared with a specific tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Cloudflare Tunnel token response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get a Cloudflare Tunnel token response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelGetACloudflareTunnelTokenAsync(String tunnelId, String accountId, final ApiCallback<TunnelTunnelResponseToken> _callback) throws ApiException {

        okhttp3.Call localVarCall = cloudflareTunnelGetACloudflareTunnelTokenValidateBeforeCall(tunnelId, accountId, _callback);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseToken>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for cloudflareTunnelGetAWarpConnectorTunnel
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Warp Connector Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get a Warp Connector Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelGetAWarpConnectorTunnelCall(String tunnelId, String accountId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/warp_connector/{tunnel_id}"
            .replace("{" + "tunnel_id" + "}", localVarApiClient.escapeString(tunnelId.toString()))
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cloudflareTunnelGetAWarpConnectorTunnelValidateBeforeCall(String tunnelId, String accountId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tunnelId' is set
        if (tunnelId == null) {
            throw new ApiException("Missing the required parameter 'tunnelId' when calling cloudflareTunnelGetAWarpConnectorTunnel(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cloudflareTunnelGetAWarpConnectorTunnel(Async)");
        }

        return cloudflareTunnelGetAWarpConnectorTunnelCall(tunnelId, accountId, _callback);

    }

    /**
     * Get a Warp Connector Tunnel
     * Fetches a single Warp Connector Tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @return TunnelTunnelResponseSingle
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Warp Connector Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get a Warp Connector Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public TunnelTunnelResponseSingle cloudflareTunnelGetAWarpConnectorTunnel(String tunnelId, String accountId) throws ApiException {
        ApiResponse<TunnelTunnelResponseSingle> localVarResp = cloudflareTunnelGetAWarpConnectorTunnelWithHttpInfo(tunnelId, accountId);
        return localVarResp.getData();
    }

    /**
     * Get a Warp Connector Tunnel
     * Fetches a single Warp Connector Tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @return ApiResponse&lt;TunnelTunnelResponseSingle&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Warp Connector Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get a Warp Connector Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TunnelTunnelResponseSingle> cloudflareTunnelGetAWarpConnectorTunnelWithHttpInfo(String tunnelId, String accountId) throws ApiException {
        okhttp3.Call localVarCall = cloudflareTunnelGetAWarpConnectorTunnelValidateBeforeCall(tunnelId, accountId, null);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseSingle>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a Warp Connector Tunnel (asynchronously)
     * Fetches a single Warp Connector Tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Warp Connector Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get a Warp Connector Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelGetAWarpConnectorTunnelAsync(String tunnelId, String accountId, final ApiCallback<TunnelTunnelResponseSingle> _callback) throws ApiException {

        okhttp3.Call localVarCall = cloudflareTunnelGetAWarpConnectorTunnelValidateBeforeCall(tunnelId, accountId, _callback);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseSingle>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for cloudflareTunnelGetAWarpConnectorTunnelToken
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Warp Connector Tunnel token response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get a Warp Connector Tunnel token response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelGetAWarpConnectorTunnelTokenCall(String tunnelId, String accountId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/warp_connector/{tunnel_id}/token"
            .replace("{" + "tunnel_id" + "}", localVarApiClient.escapeString(tunnelId.toString()))
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cloudflareTunnelGetAWarpConnectorTunnelTokenValidateBeforeCall(String tunnelId, String accountId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tunnelId' is set
        if (tunnelId == null) {
            throw new ApiException("Missing the required parameter 'tunnelId' when calling cloudflareTunnelGetAWarpConnectorTunnelToken(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cloudflareTunnelGetAWarpConnectorTunnelToken(Async)");
        }

        return cloudflareTunnelGetAWarpConnectorTunnelTokenCall(tunnelId, accountId, _callback);

    }

    /**
     * Get a Warp Connector Tunnel token
     * Gets the token used to associate warp device with a specific Warp Connector tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @return TunnelTunnelResponseToken
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Warp Connector Tunnel token response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get a Warp Connector Tunnel token response failure </td><td>  -  </td></tr>
     </table>
     */
    public TunnelTunnelResponseToken cloudflareTunnelGetAWarpConnectorTunnelToken(String tunnelId, String accountId) throws ApiException {
        ApiResponse<TunnelTunnelResponseToken> localVarResp = cloudflareTunnelGetAWarpConnectorTunnelTokenWithHttpInfo(tunnelId, accountId);
        return localVarResp.getData();
    }

    /**
     * Get a Warp Connector Tunnel token
     * Gets the token used to associate warp device with a specific Warp Connector tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @return ApiResponse&lt;TunnelTunnelResponseToken&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Warp Connector Tunnel token response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get a Warp Connector Tunnel token response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TunnelTunnelResponseToken> cloudflareTunnelGetAWarpConnectorTunnelTokenWithHttpInfo(String tunnelId, String accountId) throws ApiException {
        okhttp3.Call localVarCall = cloudflareTunnelGetAWarpConnectorTunnelTokenValidateBeforeCall(tunnelId, accountId, null);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseToken>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a Warp Connector Tunnel token (asynchronously)
     * Gets the token used to associate warp device with a specific Warp Connector tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get a Warp Connector Tunnel token response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get a Warp Connector Tunnel token response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelGetAWarpConnectorTunnelTokenAsync(String tunnelId, String accountId, final ApiCallback<TunnelTunnelResponseToken> _callback) throws ApiException {

        okhttp3.Call localVarCall = cloudflareTunnelGetAWarpConnectorTunnelTokenValidateBeforeCall(tunnelId, accountId, _callback);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseToken>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for cloudflareTunnelGetCloudflareTunnelConnector
     * @param accountId  (required)
     * @param tunnelId  (required)
     * @param connectorId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get Cloudflare Tunnel connector response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get Cloudflare Tunnel connector response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelGetCloudflareTunnelConnectorCall(String accountId, String tunnelId, String connectorId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/cfd_tunnel/{tunnel_id}/connectors/{connector_id}"
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()))
            .replace("{" + "tunnel_id" + "}", localVarApiClient.escapeString(tunnelId.toString()))
            .replace("{" + "connector_id" + "}", localVarApiClient.escapeString(connectorId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cloudflareTunnelGetCloudflareTunnelConnectorValidateBeforeCall(String accountId, String tunnelId, String connectorId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cloudflareTunnelGetCloudflareTunnelConnector(Async)");
        }

        // verify the required parameter 'tunnelId' is set
        if (tunnelId == null) {
            throw new ApiException("Missing the required parameter 'tunnelId' when calling cloudflareTunnelGetCloudflareTunnelConnector(Async)");
        }

        // verify the required parameter 'connectorId' is set
        if (connectorId == null) {
            throw new ApiException("Missing the required parameter 'connectorId' when calling cloudflareTunnelGetCloudflareTunnelConnector(Async)");
        }

        return cloudflareTunnelGetCloudflareTunnelConnectorCall(accountId, tunnelId, connectorId, _callback);

    }

    /**
     * Get Cloudflare Tunnel connector
     * Fetches connector and connection details for a Cloudflare Tunnel.
     * @param accountId  (required)
     * @param tunnelId  (required)
     * @param connectorId  (required)
     * @return TunnelTunnelClientResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get Cloudflare Tunnel connector response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get Cloudflare Tunnel connector response failure </td><td>  -  </td></tr>
     </table>
     */
    public TunnelTunnelClientResponse cloudflareTunnelGetCloudflareTunnelConnector(String accountId, String tunnelId, String connectorId) throws ApiException {
        ApiResponse<TunnelTunnelClientResponse> localVarResp = cloudflareTunnelGetCloudflareTunnelConnectorWithHttpInfo(accountId, tunnelId, connectorId);
        return localVarResp.getData();
    }

    /**
     * Get Cloudflare Tunnel connector
     * Fetches connector and connection details for a Cloudflare Tunnel.
     * @param accountId  (required)
     * @param tunnelId  (required)
     * @param connectorId  (required)
     * @return ApiResponse&lt;TunnelTunnelClientResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get Cloudflare Tunnel connector response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get Cloudflare Tunnel connector response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TunnelTunnelClientResponse> cloudflareTunnelGetCloudflareTunnelConnectorWithHttpInfo(String accountId, String tunnelId, String connectorId) throws ApiException {
        okhttp3.Call localVarCall = cloudflareTunnelGetCloudflareTunnelConnectorValidateBeforeCall(accountId, tunnelId, connectorId, null);
        Type localVarReturnType = new TypeToken<TunnelTunnelClientResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get Cloudflare Tunnel connector (asynchronously)
     * Fetches connector and connection details for a Cloudflare Tunnel.
     * @param accountId  (required)
     * @param tunnelId  (required)
     * @param connectorId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Get Cloudflare Tunnel connector response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Get Cloudflare Tunnel connector response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelGetCloudflareTunnelConnectorAsync(String accountId, String tunnelId, String connectorId, final ApiCallback<TunnelTunnelClientResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = cloudflareTunnelGetCloudflareTunnelConnectorValidateBeforeCall(accountId, tunnelId, connectorId, _callback);
        Type localVarReturnType = new TypeToken<TunnelTunnelClientResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for cloudflareTunnelListAllTunnels
     * @param accountId  (required)
     * @param name  (optional)
     * @param isDeleted  (optional)
     * @param existedAt  (optional)
     * @param uuid  (optional)
     * @param wasActiveAt  (optional)
     * @param wasInactiveAt  (optional)
     * @param includePrefix  (optional)
     * @param excludePrefix  (optional)
     * @param tunTypes  (optional)
     * @param perPage  (optional)
     * @param page  (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List Tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List Tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelListAllTunnelsCall(String accountId, String name, Boolean isDeleted, OffsetDateTime existedAt, String uuid, OffsetDateTime wasActiveAt, OffsetDateTime wasInactiveAt, String includePrefix, String excludePrefix, String tunTypes, BigDecimal perPage, BigDecimal page, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/tunnels"
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (name != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("name", name));
        }

        if (isDeleted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("is_deleted", isDeleted));
        }

        if (existedAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("existed_at", existedAt));
        }

        if (uuid != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("uuid", uuid));
        }

        if (wasActiveAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("was_active_at", wasActiveAt));
        }

        if (wasInactiveAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("was_inactive_at", wasInactiveAt));
        }

        if (includePrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("include_prefix", includePrefix));
        }

        if (excludePrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("exclude_prefix", excludePrefix));
        }

        if (tunTypes != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("tun_types", tunTypes));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cloudflareTunnelListAllTunnelsValidateBeforeCall(String accountId, String name, Boolean isDeleted, OffsetDateTime existedAt, String uuid, OffsetDateTime wasActiveAt, OffsetDateTime wasInactiveAt, String includePrefix, String excludePrefix, String tunTypes, BigDecimal perPage, BigDecimal page, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cloudflareTunnelListAllTunnels(Async)");
        }

        return cloudflareTunnelListAllTunnelsCall(accountId, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, tunTypes, perPage, page, _callback);

    }

    /**
     * List All Tunnels
     * Lists and filters all types of Tunnels in an account.
     * @param accountId  (required)
     * @param name  (optional)
     * @param isDeleted  (optional)
     * @param existedAt  (optional)
     * @param uuid  (optional)
     * @param wasActiveAt  (optional)
     * @param wasInactiveAt  (optional)
     * @param includePrefix  (optional)
     * @param excludePrefix  (optional)
     * @param tunTypes  (optional)
     * @param perPage  (optional)
     * @param page  (optional, default to 1)
     * @return TunnelTunnelResponseCollection
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List Tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List Tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public TunnelTunnelResponseCollection cloudflareTunnelListAllTunnels(String accountId, String name, Boolean isDeleted, OffsetDateTime existedAt, String uuid, OffsetDateTime wasActiveAt, OffsetDateTime wasInactiveAt, String includePrefix, String excludePrefix, String tunTypes, BigDecimal perPage, BigDecimal page) throws ApiException {
        ApiResponse<TunnelTunnelResponseCollection> localVarResp = cloudflareTunnelListAllTunnelsWithHttpInfo(accountId, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, tunTypes, perPage, page);
        return localVarResp.getData();
    }

    /**
     * List All Tunnels
     * Lists and filters all types of Tunnels in an account.
     * @param accountId  (required)
     * @param name  (optional)
     * @param isDeleted  (optional)
     * @param existedAt  (optional)
     * @param uuid  (optional)
     * @param wasActiveAt  (optional)
     * @param wasInactiveAt  (optional)
     * @param includePrefix  (optional)
     * @param excludePrefix  (optional)
     * @param tunTypes  (optional)
     * @param perPage  (optional)
     * @param page  (optional, default to 1)
     * @return ApiResponse&lt;TunnelTunnelResponseCollection&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List Tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List Tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TunnelTunnelResponseCollection> cloudflareTunnelListAllTunnelsWithHttpInfo(String accountId, String name, Boolean isDeleted, OffsetDateTime existedAt, String uuid, OffsetDateTime wasActiveAt, OffsetDateTime wasInactiveAt, String includePrefix, String excludePrefix, String tunTypes, BigDecimal perPage, BigDecimal page) throws ApiException {
        okhttp3.Call localVarCall = cloudflareTunnelListAllTunnelsValidateBeforeCall(accountId, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, tunTypes, perPage, page, null);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseCollection>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List All Tunnels (asynchronously)
     * Lists and filters all types of Tunnels in an account.
     * @param accountId  (required)
     * @param name  (optional)
     * @param isDeleted  (optional)
     * @param existedAt  (optional)
     * @param uuid  (optional)
     * @param wasActiveAt  (optional)
     * @param wasInactiveAt  (optional)
     * @param includePrefix  (optional)
     * @param excludePrefix  (optional)
     * @param tunTypes  (optional)
     * @param perPage  (optional)
     * @param page  (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List Tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List Tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelListAllTunnelsAsync(String accountId, String name, Boolean isDeleted, OffsetDateTime existedAt, String uuid, OffsetDateTime wasActiveAt, OffsetDateTime wasInactiveAt, String includePrefix, String excludePrefix, String tunTypes, BigDecimal perPage, BigDecimal page, final ApiCallback<TunnelTunnelResponseCollection> _callback) throws ApiException {

        okhttp3.Call localVarCall = cloudflareTunnelListAllTunnelsValidateBeforeCall(accountId, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, tunTypes, perPage, page, _callback);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseCollection>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for cloudflareTunnelListCloudflareTunnelConnections
     * @param accountId  (required)
     * @param tunnelId  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List Cloudflare Tunnel connections response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List Cloudflare Tunnel connections response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelListCloudflareTunnelConnectionsCall(String accountId, String tunnelId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/cfd_tunnel/{tunnel_id}/connections"
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()))
            .replace("{" + "tunnel_id" + "}", localVarApiClient.escapeString(tunnelId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cloudflareTunnelListCloudflareTunnelConnectionsValidateBeforeCall(String accountId, String tunnelId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cloudflareTunnelListCloudflareTunnelConnections(Async)");
        }

        // verify the required parameter 'tunnelId' is set
        if (tunnelId == null) {
            throw new ApiException("Missing the required parameter 'tunnelId' when calling cloudflareTunnelListCloudflareTunnelConnections(Async)");
        }

        return cloudflareTunnelListCloudflareTunnelConnectionsCall(accountId, tunnelId, _callback);

    }

    /**
     * List Cloudflare Tunnel connections
     * Fetches connection details for a Cloudflare Tunnel.
     * @param accountId  (required)
     * @param tunnelId  (required)
     * @return TunnelTunnelConnectionsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List Cloudflare Tunnel connections response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List Cloudflare Tunnel connections response failure </td><td>  -  </td></tr>
     </table>
     */
    public TunnelTunnelConnectionsResponse cloudflareTunnelListCloudflareTunnelConnections(String accountId, String tunnelId) throws ApiException {
        ApiResponse<TunnelTunnelConnectionsResponse> localVarResp = cloudflareTunnelListCloudflareTunnelConnectionsWithHttpInfo(accountId, tunnelId);
        return localVarResp.getData();
    }

    /**
     * List Cloudflare Tunnel connections
     * Fetches connection details for a Cloudflare Tunnel.
     * @param accountId  (required)
     * @param tunnelId  (required)
     * @return ApiResponse&lt;TunnelTunnelConnectionsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List Cloudflare Tunnel connections response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List Cloudflare Tunnel connections response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TunnelTunnelConnectionsResponse> cloudflareTunnelListCloudflareTunnelConnectionsWithHttpInfo(String accountId, String tunnelId) throws ApiException {
        okhttp3.Call localVarCall = cloudflareTunnelListCloudflareTunnelConnectionsValidateBeforeCall(accountId, tunnelId, null);
        Type localVarReturnType = new TypeToken<TunnelTunnelConnectionsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Cloudflare Tunnel connections (asynchronously)
     * Fetches connection details for a Cloudflare Tunnel.
     * @param accountId  (required)
     * @param tunnelId  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List Cloudflare Tunnel connections response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List Cloudflare Tunnel connections response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelListCloudflareTunnelConnectionsAsync(String accountId, String tunnelId, final ApiCallback<TunnelTunnelConnectionsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = cloudflareTunnelListCloudflareTunnelConnectionsValidateBeforeCall(accountId, tunnelId, _callback);
        Type localVarReturnType = new TypeToken<TunnelTunnelConnectionsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for cloudflareTunnelListCloudflareTunnels
     * @param accountId  (required)
     * @param name  (optional)
     * @param isDeleted  (optional)
     * @param existedAt  (optional)
     * @param uuid  (optional)
     * @param wasActiveAt  (optional)
     * @param wasInactiveAt  (optional)
     * @param includePrefix  (optional)
     * @param excludePrefix  (optional)
     * @param perPage  (optional)
     * @param page  (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List Cloudflare Tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List Cloudflare Tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelListCloudflareTunnelsCall(String accountId, String name, Boolean isDeleted, OffsetDateTime existedAt, String uuid, OffsetDateTime wasActiveAt, OffsetDateTime wasInactiveAt, String includePrefix, String excludePrefix, BigDecimal perPage, BigDecimal page, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/cfd_tunnel"
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (name != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("name", name));
        }

        if (isDeleted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("is_deleted", isDeleted));
        }

        if (existedAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("existed_at", existedAt));
        }

        if (uuid != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("uuid", uuid));
        }

        if (wasActiveAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("was_active_at", wasActiveAt));
        }

        if (wasInactiveAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("was_inactive_at", wasInactiveAt));
        }

        if (includePrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("include_prefix", includePrefix));
        }

        if (excludePrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("exclude_prefix", excludePrefix));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cloudflareTunnelListCloudflareTunnelsValidateBeforeCall(String accountId, String name, Boolean isDeleted, OffsetDateTime existedAt, String uuid, OffsetDateTime wasActiveAt, OffsetDateTime wasInactiveAt, String includePrefix, String excludePrefix, BigDecimal perPage, BigDecimal page, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cloudflareTunnelListCloudflareTunnels(Async)");
        }

        return cloudflareTunnelListCloudflareTunnelsCall(accountId, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, perPage, page, _callback);

    }

    /**
     * List Cloudflare Tunnels
     * Lists and filters Cloudflare Tunnels in an account.
     * @param accountId  (required)
     * @param name  (optional)
     * @param isDeleted  (optional)
     * @param existedAt  (optional)
     * @param uuid  (optional)
     * @param wasActiveAt  (optional)
     * @param wasInactiveAt  (optional)
     * @param includePrefix  (optional)
     * @param excludePrefix  (optional)
     * @param perPage  (optional)
     * @param page  (optional, default to 1)
     * @return TunnelTunnelResponseCollection
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List Cloudflare Tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List Cloudflare Tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public TunnelTunnelResponseCollection cloudflareTunnelListCloudflareTunnels(String accountId, String name, Boolean isDeleted, OffsetDateTime existedAt, String uuid, OffsetDateTime wasActiveAt, OffsetDateTime wasInactiveAt, String includePrefix, String excludePrefix, BigDecimal perPage, BigDecimal page) throws ApiException {
        ApiResponse<TunnelTunnelResponseCollection> localVarResp = cloudflareTunnelListCloudflareTunnelsWithHttpInfo(accountId, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, perPage, page);
        return localVarResp.getData();
    }

    /**
     * List Cloudflare Tunnels
     * Lists and filters Cloudflare Tunnels in an account.
     * @param accountId  (required)
     * @param name  (optional)
     * @param isDeleted  (optional)
     * @param existedAt  (optional)
     * @param uuid  (optional)
     * @param wasActiveAt  (optional)
     * @param wasInactiveAt  (optional)
     * @param includePrefix  (optional)
     * @param excludePrefix  (optional)
     * @param perPage  (optional)
     * @param page  (optional, default to 1)
     * @return ApiResponse&lt;TunnelTunnelResponseCollection&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List Cloudflare Tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List Cloudflare Tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TunnelTunnelResponseCollection> cloudflareTunnelListCloudflareTunnelsWithHttpInfo(String accountId, String name, Boolean isDeleted, OffsetDateTime existedAt, String uuid, OffsetDateTime wasActiveAt, OffsetDateTime wasInactiveAt, String includePrefix, String excludePrefix, BigDecimal perPage, BigDecimal page) throws ApiException {
        okhttp3.Call localVarCall = cloudflareTunnelListCloudflareTunnelsValidateBeforeCall(accountId, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, perPage, page, null);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseCollection>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Cloudflare Tunnels (asynchronously)
     * Lists and filters Cloudflare Tunnels in an account.
     * @param accountId  (required)
     * @param name  (optional)
     * @param isDeleted  (optional)
     * @param existedAt  (optional)
     * @param uuid  (optional)
     * @param wasActiveAt  (optional)
     * @param wasInactiveAt  (optional)
     * @param includePrefix  (optional)
     * @param excludePrefix  (optional)
     * @param perPage  (optional)
     * @param page  (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List Cloudflare Tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List Cloudflare Tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelListCloudflareTunnelsAsync(String accountId, String name, Boolean isDeleted, OffsetDateTime existedAt, String uuid, OffsetDateTime wasActiveAt, OffsetDateTime wasInactiveAt, String includePrefix, String excludePrefix, BigDecimal perPage, BigDecimal page, final ApiCallback<TunnelTunnelResponseCollection> _callback) throws ApiException {

        okhttp3.Call localVarCall = cloudflareTunnelListCloudflareTunnelsValidateBeforeCall(accountId, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, perPage, page, _callback);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseCollection>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for cloudflareTunnelListWarpConnectorTunnels
     * @param accountId  (required)
     * @param name  (optional)
     * @param isDeleted  (optional)
     * @param existedAt  (optional)
     * @param uuid  (optional)
     * @param wasActiveAt  (optional)
     * @param wasInactiveAt  (optional)
     * @param includePrefix  (optional)
     * @param excludePrefix  (optional)
     * @param perPage  (optional)
     * @param page  (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List Warp Connector Tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List Warp Connector Tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelListWarpConnectorTunnelsCall(String accountId, String name, Boolean isDeleted, OffsetDateTime existedAt, String uuid, OffsetDateTime wasActiveAt, OffsetDateTime wasInactiveAt, String includePrefix, String excludePrefix, BigDecimal perPage, BigDecimal page, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/warp_connector"
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (name != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("name", name));
        }

        if (isDeleted != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("is_deleted", isDeleted));
        }

        if (existedAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("existed_at", existedAt));
        }

        if (uuid != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("uuid", uuid));
        }

        if (wasActiveAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("was_active_at", wasActiveAt));
        }

        if (wasInactiveAt != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("was_inactive_at", wasInactiveAt));
        }

        if (includePrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("include_prefix", includePrefix));
        }

        if (excludePrefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("exclude_prefix", excludePrefix));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cloudflareTunnelListWarpConnectorTunnelsValidateBeforeCall(String accountId, String name, Boolean isDeleted, OffsetDateTime existedAt, String uuid, OffsetDateTime wasActiveAt, OffsetDateTime wasInactiveAt, String includePrefix, String excludePrefix, BigDecimal perPage, BigDecimal page, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cloudflareTunnelListWarpConnectorTunnels(Async)");
        }

        return cloudflareTunnelListWarpConnectorTunnelsCall(accountId, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, perPage, page, _callback);

    }

    /**
     * List Warp Connector Tunnels
     * Lists and filters Warp Connector Tunnels in an account.
     * @param accountId  (required)
     * @param name  (optional)
     * @param isDeleted  (optional)
     * @param existedAt  (optional)
     * @param uuid  (optional)
     * @param wasActiveAt  (optional)
     * @param wasInactiveAt  (optional)
     * @param includePrefix  (optional)
     * @param excludePrefix  (optional)
     * @param perPage  (optional)
     * @param page  (optional, default to 1)
     * @return TunnelTunnelResponseCollection
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List Warp Connector Tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List Warp Connector Tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public TunnelTunnelResponseCollection cloudflareTunnelListWarpConnectorTunnels(String accountId, String name, Boolean isDeleted, OffsetDateTime existedAt, String uuid, OffsetDateTime wasActiveAt, OffsetDateTime wasInactiveAt, String includePrefix, String excludePrefix, BigDecimal perPage, BigDecimal page) throws ApiException {
        ApiResponse<TunnelTunnelResponseCollection> localVarResp = cloudflareTunnelListWarpConnectorTunnelsWithHttpInfo(accountId, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, perPage, page);
        return localVarResp.getData();
    }

    /**
     * List Warp Connector Tunnels
     * Lists and filters Warp Connector Tunnels in an account.
     * @param accountId  (required)
     * @param name  (optional)
     * @param isDeleted  (optional)
     * @param existedAt  (optional)
     * @param uuid  (optional)
     * @param wasActiveAt  (optional)
     * @param wasInactiveAt  (optional)
     * @param includePrefix  (optional)
     * @param excludePrefix  (optional)
     * @param perPage  (optional)
     * @param page  (optional, default to 1)
     * @return ApiResponse&lt;TunnelTunnelResponseCollection&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List Warp Connector Tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List Warp Connector Tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TunnelTunnelResponseCollection> cloudflareTunnelListWarpConnectorTunnelsWithHttpInfo(String accountId, String name, Boolean isDeleted, OffsetDateTime existedAt, String uuid, OffsetDateTime wasActiveAt, OffsetDateTime wasInactiveAt, String includePrefix, String excludePrefix, BigDecimal perPage, BigDecimal page) throws ApiException {
        okhttp3.Call localVarCall = cloudflareTunnelListWarpConnectorTunnelsValidateBeforeCall(accountId, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, perPage, page, null);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseCollection>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List Warp Connector Tunnels (asynchronously)
     * Lists and filters Warp Connector Tunnels in an account.
     * @param accountId  (required)
     * @param name  (optional)
     * @param isDeleted  (optional)
     * @param existedAt  (optional)
     * @param uuid  (optional)
     * @param wasActiveAt  (optional)
     * @param wasInactiveAt  (optional)
     * @param includePrefix  (optional)
     * @param excludePrefix  (optional)
     * @param perPage  (optional)
     * @param page  (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> List Warp Connector Tunnels response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> List Warp Connector Tunnels response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelListWarpConnectorTunnelsAsync(String accountId, String name, Boolean isDeleted, OffsetDateTime existedAt, String uuid, OffsetDateTime wasActiveAt, OffsetDateTime wasInactiveAt, String includePrefix, String excludePrefix, BigDecimal perPage, BigDecimal page, final ApiCallback<TunnelTunnelResponseCollection> _callback) throws ApiException {

        okhttp3.Call localVarCall = cloudflareTunnelListWarpConnectorTunnelsValidateBeforeCall(accountId, name, isDeleted, existedAt, uuid, wasActiveAt, wasInactiveAt, includePrefix, excludePrefix, perPage, page, _callback);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseCollection>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for cloudflareTunnelUpdateACloudflareTunnel
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param cloudflareTunnelUpdateACloudflareTunnelRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Update a Cloudflare Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Update a Cloudflare Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelUpdateACloudflareTunnelCall(String tunnelId, String accountId, CloudflareTunnelUpdateACloudflareTunnelRequest cloudflareTunnelUpdateACloudflareTunnelRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = cloudflareTunnelUpdateACloudflareTunnelRequest;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/cfd_tunnel/{tunnel_id}"
            .replace("{" + "tunnel_id" + "}", localVarApiClient.escapeString(tunnelId.toString()))
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cloudflareTunnelUpdateACloudflareTunnelValidateBeforeCall(String tunnelId, String accountId, CloudflareTunnelUpdateACloudflareTunnelRequest cloudflareTunnelUpdateACloudflareTunnelRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tunnelId' is set
        if (tunnelId == null) {
            throw new ApiException("Missing the required parameter 'tunnelId' when calling cloudflareTunnelUpdateACloudflareTunnel(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cloudflareTunnelUpdateACloudflareTunnel(Async)");
        }

        // verify the required parameter 'cloudflareTunnelUpdateACloudflareTunnelRequest' is set
        if (cloudflareTunnelUpdateACloudflareTunnelRequest == null) {
            throw new ApiException("Missing the required parameter 'cloudflareTunnelUpdateACloudflareTunnelRequest' when calling cloudflareTunnelUpdateACloudflareTunnel(Async)");
        }

        return cloudflareTunnelUpdateACloudflareTunnelCall(tunnelId, accountId, cloudflareTunnelUpdateACloudflareTunnelRequest, _callback);

    }

    /**
     * Update a Cloudflare Tunnel
     * Updates an existing Cloudflare Tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param cloudflareTunnelUpdateACloudflareTunnelRequest  (required)
     * @return TunnelTunnelResponseSingle
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Update a Cloudflare Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Update a Cloudflare Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public TunnelTunnelResponseSingle cloudflareTunnelUpdateACloudflareTunnel(String tunnelId, String accountId, CloudflareTunnelUpdateACloudflareTunnelRequest cloudflareTunnelUpdateACloudflareTunnelRequest) throws ApiException {
        ApiResponse<TunnelTunnelResponseSingle> localVarResp = cloudflareTunnelUpdateACloudflareTunnelWithHttpInfo(tunnelId, accountId, cloudflareTunnelUpdateACloudflareTunnelRequest);
        return localVarResp.getData();
    }

    /**
     * Update a Cloudflare Tunnel
     * Updates an existing Cloudflare Tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param cloudflareTunnelUpdateACloudflareTunnelRequest  (required)
     * @return ApiResponse&lt;TunnelTunnelResponseSingle&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Update a Cloudflare Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Update a Cloudflare Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TunnelTunnelResponseSingle> cloudflareTunnelUpdateACloudflareTunnelWithHttpInfo(String tunnelId, String accountId, CloudflareTunnelUpdateACloudflareTunnelRequest cloudflareTunnelUpdateACloudflareTunnelRequest) throws ApiException {
        okhttp3.Call localVarCall = cloudflareTunnelUpdateACloudflareTunnelValidateBeforeCall(tunnelId, accountId, cloudflareTunnelUpdateACloudflareTunnelRequest, null);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseSingle>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update a Cloudflare Tunnel (asynchronously)
     * Updates an existing Cloudflare Tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param cloudflareTunnelUpdateACloudflareTunnelRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Update a Cloudflare Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Update a Cloudflare Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelUpdateACloudflareTunnelAsync(String tunnelId, String accountId, CloudflareTunnelUpdateACloudflareTunnelRequest cloudflareTunnelUpdateACloudflareTunnelRequest, final ApiCallback<TunnelTunnelResponseSingle> _callback) throws ApiException {

        okhttp3.Call localVarCall = cloudflareTunnelUpdateACloudflareTunnelValidateBeforeCall(tunnelId, accountId, cloudflareTunnelUpdateACloudflareTunnelRequest, _callback);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseSingle>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for cloudflareTunnelUpdateAWarpConnectorTunnel
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param cloudflareTunnelUpdateACloudflareTunnelRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Update a Warp Connector Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Update a Warp Connector Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelUpdateAWarpConnectorTunnelCall(String tunnelId, String accountId, CloudflareTunnelUpdateACloudflareTunnelRequest cloudflareTunnelUpdateACloudflareTunnelRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = cloudflareTunnelUpdateACloudflareTunnelRequest;

        // create path and map variables
        String localVarPath = "/accounts/{account_id}/warp_connector/{tunnel_id}"
            .replace("{" + "tunnel_id" + "}", localVarApiClient.escapeString(tunnelId.toString()))
            .replace("{" + "account_id" + "}", localVarApiClient.escapeString(accountId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call cloudflareTunnelUpdateAWarpConnectorTunnelValidateBeforeCall(String tunnelId, String accountId, CloudflareTunnelUpdateACloudflareTunnelRequest cloudflareTunnelUpdateACloudflareTunnelRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tunnelId' is set
        if (tunnelId == null) {
            throw new ApiException("Missing the required parameter 'tunnelId' when calling cloudflareTunnelUpdateAWarpConnectorTunnel(Async)");
        }

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            throw new ApiException("Missing the required parameter 'accountId' when calling cloudflareTunnelUpdateAWarpConnectorTunnel(Async)");
        }

        // verify the required parameter 'cloudflareTunnelUpdateACloudflareTunnelRequest' is set
        if (cloudflareTunnelUpdateACloudflareTunnelRequest == null) {
            throw new ApiException("Missing the required parameter 'cloudflareTunnelUpdateACloudflareTunnelRequest' when calling cloudflareTunnelUpdateAWarpConnectorTunnel(Async)");
        }

        return cloudflareTunnelUpdateAWarpConnectorTunnelCall(tunnelId, accountId, cloudflareTunnelUpdateACloudflareTunnelRequest, _callback);

    }

    /**
     * Update a Warp Connector Tunnel
     * Updates an existing Warp Connector Tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param cloudflareTunnelUpdateACloudflareTunnelRequest  (required)
     * @return TunnelTunnelResponseSingle
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Update a Warp Connector Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Update a Warp Connector Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public TunnelTunnelResponseSingle cloudflareTunnelUpdateAWarpConnectorTunnel(String tunnelId, String accountId, CloudflareTunnelUpdateACloudflareTunnelRequest cloudflareTunnelUpdateACloudflareTunnelRequest) throws ApiException {
        ApiResponse<TunnelTunnelResponseSingle> localVarResp = cloudflareTunnelUpdateAWarpConnectorTunnelWithHttpInfo(tunnelId, accountId, cloudflareTunnelUpdateACloudflareTunnelRequest);
        return localVarResp.getData();
    }

    /**
     * Update a Warp Connector Tunnel
     * Updates an existing Warp Connector Tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param cloudflareTunnelUpdateACloudflareTunnelRequest  (required)
     * @return ApiResponse&lt;TunnelTunnelResponseSingle&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Update a Warp Connector Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Update a Warp Connector Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<TunnelTunnelResponseSingle> cloudflareTunnelUpdateAWarpConnectorTunnelWithHttpInfo(String tunnelId, String accountId, CloudflareTunnelUpdateACloudflareTunnelRequest cloudflareTunnelUpdateACloudflareTunnelRequest) throws ApiException {
        okhttp3.Call localVarCall = cloudflareTunnelUpdateAWarpConnectorTunnelValidateBeforeCall(tunnelId, accountId, cloudflareTunnelUpdateACloudflareTunnelRequest, null);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseSingle>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update a Warp Connector Tunnel (asynchronously)
     * Updates an existing Warp Connector Tunnel.
     * @param tunnelId  (required)
     * @param accountId  (required)
     * @param cloudflareTunnelUpdateACloudflareTunnelRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Update a Warp Connector Tunnel response </td><td>  -  </td></tr>
        <tr><td> 4XX </td><td> Update a Warp Connector Tunnel response failure </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call cloudflareTunnelUpdateAWarpConnectorTunnelAsync(String tunnelId, String accountId, CloudflareTunnelUpdateACloudflareTunnelRequest cloudflareTunnelUpdateACloudflareTunnelRequest, final ApiCallback<TunnelTunnelResponseSingle> _callback) throws ApiException {

        okhttp3.Call localVarCall = cloudflareTunnelUpdateAWarpConnectorTunnelValidateBeforeCall(tunnelId, accountId, cloudflareTunnelUpdateACloudflareTunnelRequest, _callback);
        Type localVarReturnType = new TypeToken<TunnelTunnelResponseSingle>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
