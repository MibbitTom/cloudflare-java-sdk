/*
 * Cloudflare API
 * To get started using Cloudflare's products and services via the API, refer to [how to interact with Cloudflare](https://developers.cloudflare.com/fundamentals/basic-tasks/interact-with-cloudflare/), which covers using tools like [Terraform](https://developers.cloudflare.com/terraform/#cloudflare-terraform) and the [official SDKs](https://developers.cloudflare.com/fundamentals/api/reference/sdks/) to maintain your Cloudflare resources.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * The version of the OpenAPI document: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Arrays;
import org.openapitools.client.model.TeamsDevicesServiceModeV2;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import invalidPackageName.JSON;

/**
 * DevicesCreateDeviceSettingsPolicyRequest
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-04-22T11:29:23.936635354+01:00[Europe/London]", comments = "Generator version: 7.5.0")
public class DevicesCreateDeviceSettingsPolicyRequest {
  public static final String SERIALIZED_NAME_ALLOW_MODE_SWITCH = "allow_mode_switch";
  @SerializedName(SERIALIZED_NAME_ALLOW_MODE_SWITCH)
  private Boolean allowModeSwitch;

  public static final String SERIALIZED_NAME_ALLOW_UPDATES = "allow_updates";
  @SerializedName(SERIALIZED_NAME_ALLOW_UPDATES)
  private Boolean allowUpdates;

  public static final String SERIALIZED_NAME_ALLOWED_TO_LEAVE = "allowed_to_leave";
  @SerializedName(SERIALIZED_NAME_ALLOWED_TO_LEAVE)
  private Boolean allowedToLeave;

  public static final String SERIALIZED_NAME_AUTO_CONNECT = "auto_connect";
  @SerializedName(SERIALIZED_NAME_AUTO_CONNECT)
  private BigDecimal autoConnect;

  public static final String SERIALIZED_NAME_CAPTIVE_PORTAL = "captive_portal";
  @SerializedName(SERIALIZED_NAME_CAPTIVE_PORTAL)
  private BigDecimal captivePortal;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  private String description;

  public static final String SERIALIZED_NAME_DISABLE_AUTO_FALLBACK = "disable_auto_fallback";
  @SerializedName(SERIALIZED_NAME_DISABLE_AUTO_FALLBACK)
  private Boolean disableAutoFallback;

  public static final String SERIALIZED_NAME_ENABLED = "enabled";
  @SerializedName(SERIALIZED_NAME_ENABLED)
  private Boolean enabled;

  public static final String SERIALIZED_NAME_EXCLUDE_OFFICE_IPS = "exclude_office_ips";
  @SerializedName(SERIALIZED_NAME_EXCLUDE_OFFICE_IPS)
  private Boolean excludeOfficeIps;

  public static final String SERIALIZED_NAME_LAN_ALLOW_MINUTES = "lan_allow_minutes";
  @SerializedName(SERIALIZED_NAME_LAN_ALLOW_MINUTES)
  private BigDecimal lanAllowMinutes;

  public static final String SERIALIZED_NAME_LAN_ALLOW_SUBNET_SIZE = "lan_allow_subnet_size";
  @SerializedName(SERIALIZED_NAME_LAN_ALLOW_SUBNET_SIZE)
  private BigDecimal lanAllowSubnetSize;

  public static final String SERIALIZED_NAME_MATCH = "match";
  @SerializedName(SERIALIZED_NAME_MATCH)
  private String match;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_PRECEDENCE = "precedence";
  @SerializedName(SERIALIZED_NAME_PRECEDENCE)
  private BigDecimal precedence;

  public static final String SERIALIZED_NAME_SERVICE_MODE_V2 = "service_mode_v2";
  @SerializedName(SERIALIZED_NAME_SERVICE_MODE_V2)
  private TeamsDevicesServiceModeV2 serviceModeV2;

  public static final String SERIALIZED_NAME_SUPPORT_URL = "support_url";
  @SerializedName(SERIALIZED_NAME_SUPPORT_URL)
  private String supportUrl;

  public static final String SERIALIZED_NAME_SWITCH_LOCKED = "switch_locked";
  @SerializedName(SERIALIZED_NAME_SWITCH_LOCKED)
  private Boolean switchLocked;

  public DevicesCreateDeviceSettingsPolicyRequest() {
  }

  public DevicesCreateDeviceSettingsPolicyRequest allowModeSwitch(Boolean allowModeSwitch) {
    this.allowModeSwitch = allowModeSwitch;
    return this;
  }

   /**
   * Whether to allow the user to switch WARP between modes.
   * @return allowModeSwitch
  **/
  @javax.annotation.Nullable
  public Boolean getAllowModeSwitch() {
    return allowModeSwitch;
  }

  public void setAllowModeSwitch(Boolean allowModeSwitch) {
    this.allowModeSwitch = allowModeSwitch;
  }


  public DevicesCreateDeviceSettingsPolicyRequest allowUpdates(Boolean allowUpdates) {
    this.allowUpdates = allowUpdates;
    return this;
  }

   /**
   * Whether to receive update notifications when a new version of the client is available.
   * @return allowUpdates
  **/
  @javax.annotation.Nullable
  public Boolean getAllowUpdates() {
    return allowUpdates;
  }

  public void setAllowUpdates(Boolean allowUpdates) {
    this.allowUpdates = allowUpdates;
  }


  public DevicesCreateDeviceSettingsPolicyRequest allowedToLeave(Boolean allowedToLeave) {
    this.allowedToLeave = allowedToLeave;
    return this;
  }

   /**
   * Whether to allow devices to leave the organization.
   * @return allowedToLeave
  **/
  @javax.annotation.Nullable
  public Boolean getAllowedToLeave() {
    return allowedToLeave;
  }

  public void setAllowedToLeave(Boolean allowedToLeave) {
    this.allowedToLeave = allowedToLeave;
  }


  public DevicesCreateDeviceSettingsPolicyRequest autoConnect(BigDecimal autoConnect) {
    this.autoConnect = autoConnect;
    return this;
  }

   /**
   * The amount of time in minutes to reconnect after having been disabled.
   * @return autoConnect
  **/
  @javax.annotation.Nullable
  public BigDecimal getAutoConnect() {
    return autoConnect;
  }

  public void setAutoConnect(BigDecimal autoConnect) {
    this.autoConnect = autoConnect;
  }


  public DevicesCreateDeviceSettingsPolicyRequest captivePortal(BigDecimal captivePortal) {
    this.captivePortal = captivePortal;
    return this;
  }

   /**
   * Turn on the captive portal after the specified amount of time.
   * @return captivePortal
  **/
  @javax.annotation.Nullable
  public BigDecimal getCaptivePortal() {
    return captivePortal;
  }

  public void setCaptivePortal(BigDecimal captivePortal) {
    this.captivePortal = captivePortal;
  }


  public DevicesCreateDeviceSettingsPolicyRequest description(String description) {
    this.description = description;
    return this;
  }

   /**
   * A description of the policy.
   * @return description
  **/
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }


  public DevicesCreateDeviceSettingsPolicyRequest disableAutoFallback(Boolean disableAutoFallback) {
    this.disableAutoFallback = disableAutoFallback;
    return this;
  }

   /**
   * If the &#x60;dns_server&#x60; field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers unless this policy option is set to &#x60;true&#x60;.
   * @return disableAutoFallback
  **/
  @javax.annotation.Nullable
  public Boolean getDisableAutoFallback() {
    return disableAutoFallback;
  }

  public void setDisableAutoFallback(Boolean disableAutoFallback) {
    this.disableAutoFallback = disableAutoFallback;
  }


  public DevicesCreateDeviceSettingsPolicyRequest enabled(Boolean enabled) {
    this.enabled = enabled;
    return this;
  }

   /**
   * Whether the policy will be applied to matching devices.
   * @return enabled
  **/
  @javax.annotation.Nullable
  public Boolean getEnabled() {
    return enabled;
  }

  public void setEnabled(Boolean enabled) {
    this.enabled = enabled;
  }


  public DevicesCreateDeviceSettingsPolicyRequest excludeOfficeIps(Boolean excludeOfficeIps) {
    this.excludeOfficeIps = excludeOfficeIps;
    return this;
  }

   /**
   * Whether to add Microsoft IPs to Split Tunnel exclusions.
   * @return excludeOfficeIps
  **/
  @javax.annotation.Nullable
  public Boolean getExcludeOfficeIps() {
    return excludeOfficeIps;
  }

  public void setExcludeOfficeIps(Boolean excludeOfficeIps) {
    this.excludeOfficeIps = excludeOfficeIps;
  }


  public DevicesCreateDeviceSettingsPolicyRequest lanAllowMinutes(BigDecimal lanAllowMinutes) {
    this.lanAllowMinutes = lanAllowMinutes;
    return this;
  }

   /**
   * The amount of time in minutes a user is allowed access to their LAN. A value of 0 will allow LAN access until the next WARP reconnection, such as a reboot or a laptop waking from sleep. Note that this field is omitted from the response if null or unset.
   * @return lanAllowMinutes
  **/
  @javax.annotation.Nullable
  public BigDecimal getLanAllowMinutes() {
    return lanAllowMinutes;
  }

  public void setLanAllowMinutes(BigDecimal lanAllowMinutes) {
    this.lanAllowMinutes = lanAllowMinutes;
  }


  public DevicesCreateDeviceSettingsPolicyRequest lanAllowSubnetSize(BigDecimal lanAllowSubnetSize) {
    this.lanAllowSubnetSize = lanAllowSubnetSize;
    return this;
  }

   /**
   * The size of the subnet for the local access network. Note that this field is omitted from the response if null or unset.
   * @return lanAllowSubnetSize
  **/
  @javax.annotation.Nullable
  public BigDecimal getLanAllowSubnetSize() {
    return lanAllowSubnetSize;
  }

  public void setLanAllowSubnetSize(BigDecimal lanAllowSubnetSize) {
    this.lanAllowSubnetSize = lanAllowSubnetSize;
  }


  public DevicesCreateDeviceSettingsPolicyRequest match(String match) {
    this.match = match;
    return this;
  }

   /**
   * The wirefilter expression to match devices.
   * @return match
  **/
  @javax.annotation.Nonnull
  public String getMatch() {
    return match;
  }

  public void setMatch(String match) {
    this.match = match;
  }


  public DevicesCreateDeviceSettingsPolicyRequest name(String name) {
    this.name = name;
    return this;
  }

   /**
   * The name of the device settings profile.
   * @return name
  **/
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }


  public DevicesCreateDeviceSettingsPolicyRequest precedence(BigDecimal precedence) {
    this.precedence = precedence;
    return this;
  }

   /**
   * The precedence of the policy. Lower values indicate higher precedence. Policies will be evaluated in ascending order of this field.
   * @return precedence
  **/
  @javax.annotation.Nonnull
  public BigDecimal getPrecedence() {
    return precedence;
  }

  public void setPrecedence(BigDecimal precedence) {
    this.precedence = precedence;
  }


  public DevicesCreateDeviceSettingsPolicyRequest serviceModeV2(TeamsDevicesServiceModeV2 serviceModeV2) {
    this.serviceModeV2 = serviceModeV2;
    return this;
  }

   /**
   * Get serviceModeV2
   * @return serviceModeV2
  **/
  @javax.annotation.Nullable
  public TeamsDevicesServiceModeV2 getServiceModeV2() {
    return serviceModeV2;
  }

  public void setServiceModeV2(TeamsDevicesServiceModeV2 serviceModeV2) {
    this.serviceModeV2 = serviceModeV2;
  }


  public DevicesCreateDeviceSettingsPolicyRequest supportUrl(String supportUrl) {
    this.supportUrl = supportUrl;
    return this;
  }

   /**
   * The URL to launch when the Send Feedback button is clicked.
   * @return supportUrl
  **/
  @javax.annotation.Nullable
  public String getSupportUrl() {
    return supportUrl;
  }

  public void setSupportUrl(String supportUrl) {
    this.supportUrl = supportUrl;
  }


  public DevicesCreateDeviceSettingsPolicyRequest switchLocked(Boolean switchLocked) {
    this.switchLocked = switchLocked;
    return this;
  }

   /**
   * Whether to allow the user to turn off the WARP switch and disconnect the client.
   * @return switchLocked
  **/
  @javax.annotation.Nullable
  public Boolean getSwitchLocked() {
    return switchLocked;
  }

  public void setSwitchLocked(Boolean switchLocked) {
    this.switchLocked = switchLocked;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DevicesCreateDeviceSettingsPolicyRequest devicesCreateDeviceSettingsPolicyRequest = (DevicesCreateDeviceSettingsPolicyRequest) o;
    return Objects.equals(this.allowModeSwitch, devicesCreateDeviceSettingsPolicyRequest.allowModeSwitch) &&
        Objects.equals(this.allowUpdates, devicesCreateDeviceSettingsPolicyRequest.allowUpdates) &&
        Objects.equals(this.allowedToLeave, devicesCreateDeviceSettingsPolicyRequest.allowedToLeave) &&
        Objects.equals(this.autoConnect, devicesCreateDeviceSettingsPolicyRequest.autoConnect) &&
        Objects.equals(this.captivePortal, devicesCreateDeviceSettingsPolicyRequest.captivePortal) &&
        Objects.equals(this.description, devicesCreateDeviceSettingsPolicyRequest.description) &&
        Objects.equals(this.disableAutoFallback, devicesCreateDeviceSettingsPolicyRequest.disableAutoFallback) &&
        Objects.equals(this.enabled, devicesCreateDeviceSettingsPolicyRequest.enabled) &&
        Objects.equals(this.excludeOfficeIps, devicesCreateDeviceSettingsPolicyRequest.excludeOfficeIps) &&
        Objects.equals(this.lanAllowMinutes, devicesCreateDeviceSettingsPolicyRequest.lanAllowMinutes) &&
        Objects.equals(this.lanAllowSubnetSize, devicesCreateDeviceSettingsPolicyRequest.lanAllowSubnetSize) &&
        Objects.equals(this.match, devicesCreateDeviceSettingsPolicyRequest.match) &&
        Objects.equals(this.name, devicesCreateDeviceSettingsPolicyRequest.name) &&
        Objects.equals(this.precedence, devicesCreateDeviceSettingsPolicyRequest.precedence) &&
        Objects.equals(this.serviceModeV2, devicesCreateDeviceSettingsPolicyRequest.serviceModeV2) &&
        Objects.equals(this.supportUrl, devicesCreateDeviceSettingsPolicyRequest.supportUrl) &&
        Objects.equals(this.switchLocked, devicesCreateDeviceSettingsPolicyRequest.switchLocked);
  }

  @Override
  public int hashCode() {
    return Objects.hash(allowModeSwitch, allowUpdates, allowedToLeave, autoConnect, captivePortal, description, disableAutoFallback, enabled, excludeOfficeIps, lanAllowMinutes, lanAllowSubnetSize, match, name, precedence, serviceModeV2, supportUrl, switchLocked);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DevicesCreateDeviceSettingsPolicyRequest {\n");
    sb.append("    allowModeSwitch: ").append(toIndentedString(allowModeSwitch)).append("\n");
    sb.append("    allowUpdates: ").append(toIndentedString(allowUpdates)).append("\n");
    sb.append("    allowedToLeave: ").append(toIndentedString(allowedToLeave)).append("\n");
    sb.append("    autoConnect: ").append(toIndentedString(autoConnect)).append("\n");
    sb.append("    captivePortal: ").append(toIndentedString(captivePortal)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    disableAutoFallback: ").append(toIndentedString(disableAutoFallback)).append("\n");
    sb.append("    enabled: ").append(toIndentedString(enabled)).append("\n");
    sb.append("    excludeOfficeIps: ").append(toIndentedString(excludeOfficeIps)).append("\n");
    sb.append("    lanAllowMinutes: ").append(toIndentedString(lanAllowMinutes)).append("\n");
    sb.append("    lanAllowSubnetSize: ").append(toIndentedString(lanAllowSubnetSize)).append("\n");
    sb.append("    match: ").append(toIndentedString(match)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    precedence: ").append(toIndentedString(precedence)).append("\n");
    sb.append("    serviceModeV2: ").append(toIndentedString(serviceModeV2)).append("\n");
    sb.append("    supportUrl: ").append(toIndentedString(supportUrl)).append("\n");
    sb.append("    switchLocked: ").append(toIndentedString(switchLocked)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("allow_mode_switch");
    openapiFields.add("allow_updates");
    openapiFields.add("allowed_to_leave");
    openapiFields.add("auto_connect");
    openapiFields.add("captive_portal");
    openapiFields.add("description");
    openapiFields.add("disable_auto_fallback");
    openapiFields.add("enabled");
    openapiFields.add("exclude_office_ips");
    openapiFields.add("lan_allow_minutes");
    openapiFields.add("lan_allow_subnet_size");
    openapiFields.add("match");
    openapiFields.add("name");
    openapiFields.add("precedence");
    openapiFields.add("service_mode_v2");
    openapiFields.add("support_url");
    openapiFields.add("switch_locked");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("match");
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("precedence");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to DevicesCreateDeviceSettingsPolicyRequest
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!DevicesCreateDeviceSettingsPolicyRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in DevicesCreateDeviceSettingsPolicyRequest is not found in the empty JSON string", DevicesCreateDeviceSettingsPolicyRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!DevicesCreateDeviceSettingsPolicyRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `DevicesCreateDeviceSettingsPolicyRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : DevicesCreateDeviceSettingsPolicyRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if (!jsonObj.get("match").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `match` to be a primitive type in the JSON string but got `%s`", jsonObj.get("match").toString()));
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the optional field `service_mode_v2`
      if (jsonObj.get("service_mode_v2") != null && !jsonObj.get("service_mode_v2").isJsonNull()) {
        TeamsDevicesServiceModeV2.validateJsonElement(jsonObj.get("service_mode_v2"));
      }
      if ((jsonObj.get("support_url") != null && !jsonObj.get("support_url").isJsonNull()) && !jsonObj.get("support_url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `support_url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("support_url").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!DevicesCreateDeviceSettingsPolicyRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'DevicesCreateDeviceSettingsPolicyRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<DevicesCreateDeviceSettingsPolicyRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(DevicesCreateDeviceSettingsPolicyRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<DevicesCreateDeviceSettingsPolicyRequest>() {
           @Override
           public void write(JsonWriter out, DevicesCreateDeviceSettingsPolicyRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public DevicesCreateDeviceSettingsPolicyRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of DevicesCreateDeviceSettingsPolicyRequest given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of DevicesCreateDeviceSettingsPolicyRequest
  * @throws IOException if the JSON string is invalid with respect to DevicesCreateDeviceSettingsPolicyRequest
  */
  public static DevicesCreateDeviceSettingsPolicyRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, DevicesCreateDeviceSettingsPolicyRequest.class);
  }

 /**
  * Convert an instance of DevicesCreateDeviceSettingsPolicyRequest to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

