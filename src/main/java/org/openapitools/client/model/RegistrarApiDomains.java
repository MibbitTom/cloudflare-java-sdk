/*
 * Cloudflare API
 * To get started using Cloudflare's products and services via the API, refer to [how to interact with Cloudflare](https://developers.cloudflare.com/fundamentals/basic-tasks/interact-with-cloudflare/), which covers using tools like [Terraform](https://developers.cloudflare.com/terraform/#cloudflare-terraform) and the [official SDKs](https://developers.cloudflare.com/fundamentals/api/reference/sdks/) to maintain your Cloudflare resources.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * The version of the OpenAPI document: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.RegistrarApiRegistrantContact;
import org.openapitools.client.model.RegistrarApiTransferIn;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * RegistrarApiDomains
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-04-22T11:11:08.999300719+01:00[Europe/London]", comments = "Generator version: 7.5.0")
public class RegistrarApiDomains {
  public static final String SERIALIZED_NAME_AVAILABLE = "available";
  @SerializedName(SERIALIZED_NAME_AVAILABLE)
  private Boolean available;

  public static final String SERIALIZED_NAME_CAN_REGISTER = "can_register";
  @SerializedName(SERIALIZED_NAME_CAN_REGISTER)
  private Boolean canRegister;

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_CURRENT_REGISTRAR = "current_registrar";
  @SerializedName(SERIALIZED_NAME_CURRENT_REGISTRAR)
  private String currentRegistrar;

  public static final String SERIALIZED_NAME_EXPIRES_AT = "expires_at";
  @SerializedName(SERIALIZED_NAME_EXPIRES_AT)
  private OffsetDateTime expiresAt;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private String id;

  public static final String SERIALIZED_NAME_LOCKED = "locked";
  @SerializedName(SERIALIZED_NAME_LOCKED)
  private Boolean locked;

  public static final String SERIALIZED_NAME_REGISTRANT_CONTACT = "registrant_contact";
  @SerializedName(SERIALIZED_NAME_REGISTRANT_CONTACT)
  private RegistrarApiRegistrantContact registrantContact;

  public static final String SERIALIZED_NAME_REGISTRY_STATUSES = "registry_statuses";
  @SerializedName(SERIALIZED_NAME_REGISTRY_STATUSES)
  private String registryStatuses;

  public static final String SERIALIZED_NAME_SUPPORTED_TLD = "supported_tld";
  @SerializedName(SERIALIZED_NAME_SUPPORTED_TLD)
  private Boolean supportedTld;

  public static final String SERIALIZED_NAME_TRANSFER_IN = "transfer_in";
  @SerializedName(SERIALIZED_NAME_TRANSFER_IN)
  private RegistrarApiTransferIn transferIn;

  public static final String SERIALIZED_NAME_UPDATED_AT = "updated_at";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  private OffsetDateTime updatedAt;

  public RegistrarApiDomains() {
  }

  public RegistrarApiDomains(
     String id
  ) {
    this();
    this.id = id;
  }

  public RegistrarApiDomains available(Boolean available) {
    this.available = available;
    return this;
  }

   /**
   * Shows if a domain is available for transferring into Cloudflare Registrar.
   * @return available
  **/
  @javax.annotation.Nullable
  public Boolean getAvailable() {
    return available;
  }

  public void setAvailable(Boolean available) {
    this.available = available;
  }


  public RegistrarApiDomains canRegister(Boolean canRegister) {
    this.canRegister = canRegister;
    return this;
  }

   /**
   * Indicates if the domain can be registered as a new domain.
   * @return canRegister
  **/
  @javax.annotation.Nullable
  public Boolean getCanRegister() {
    return canRegister;
  }

  public void setCanRegister(Boolean canRegister) {
    this.canRegister = canRegister;
  }


  public RegistrarApiDomains createdAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
    return this;
  }

   /**
   * Shows time of creation.
   * @return createdAt
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }

  public void setCreatedAt(OffsetDateTime createdAt) {
    this.createdAt = createdAt;
  }


  public RegistrarApiDomains currentRegistrar(String currentRegistrar) {
    this.currentRegistrar = currentRegistrar;
    return this;
  }

   /**
   * Shows name of current registrar.
   * @return currentRegistrar
  **/
  @javax.annotation.Nullable
  public String getCurrentRegistrar() {
    return currentRegistrar;
  }

  public void setCurrentRegistrar(String currentRegistrar) {
    this.currentRegistrar = currentRegistrar;
  }


  public RegistrarApiDomains expiresAt(OffsetDateTime expiresAt) {
    this.expiresAt = expiresAt;
    return this;
  }

   /**
   * Shows when domain name registration expires.
   * @return expiresAt
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getExpiresAt() {
    return expiresAt;
  }

  public void setExpiresAt(OffsetDateTime expiresAt) {
    this.expiresAt = expiresAt;
  }


   /**
   * Domain identifier.
   * @return id
  **/
  @javax.annotation.Nullable
  public String getId() {
    return id;
  }



  public RegistrarApiDomains locked(Boolean locked) {
    this.locked = locked;
    return this;
  }

   /**
   * Shows whether a registrar lock is in place for a domain.
   * @return locked
  **/
  @javax.annotation.Nullable
  public Boolean getLocked() {
    return locked;
  }

  public void setLocked(Boolean locked) {
    this.locked = locked;
  }


  public RegistrarApiDomains registrantContact(RegistrarApiRegistrantContact registrantContact) {
    this.registrantContact = registrantContact;
    return this;
  }

   /**
   * Get registrantContact
   * @return registrantContact
  **/
  @javax.annotation.Nullable
  public RegistrarApiRegistrantContact getRegistrantContact() {
    return registrantContact;
  }

  public void setRegistrantContact(RegistrarApiRegistrantContact registrantContact) {
    this.registrantContact = registrantContact;
  }


  public RegistrarApiDomains registryStatuses(String registryStatuses) {
    this.registryStatuses = registryStatuses;
    return this;
  }

   /**
   * A comma-separated list of registry status codes. A full list of status codes can be found at [EPP Status Codes](https://www.icann.org/resources/pages/epp-status-codes-2014-06-16-en).
   * @return registryStatuses
  **/
  @javax.annotation.Nullable
  public String getRegistryStatuses() {
    return registryStatuses;
  }

  public void setRegistryStatuses(String registryStatuses) {
    this.registryStatuses = registryStatuses;
  }


  public RegistrarApiDomains supportedTld(Boolean supportedTld) {
    this.supportedTld = supportedTld;
    return this;
  }

   /**
   * Whether a particular TLD is currently supported by Cloudflare Registrar. Refer to [TLD Policies](https://www.cloudflare.com/tld-policies/) for a list of supported TLDs.
   * @return supportedTld
  **/
  @javax.annotation.Nullable
  public Boolean getSupportedTld() {
    return supportedTld;
  }

  public void setSupportedTld(Boolean supportedTld) {
    this.supportedTld = supportedTld;
  }


  public RegistrarApiDomains transferIn(RegistrarApiTransferIn transferIn) {
    this.transferIn = transferIn;
    return this;
  }

   /**
   * Get transferIn
   * @return transferIn
  **/
  @javax.annotation.Nullable
  public RegistrarApiTransferIn getTransferIn() {
    return transferIn;
  }

  public void setTransferIn(RegistrarApiTransferIn transferIn) {
    this.transferIn = transferIn;
  }


  public RegistrarApiDomains updatedAt(OffsetDateTime updatedAt) {
    this.updatedAt = updatedAt;
    return this;
  }

   /**
   * Last updated.
   * @return updatedAt
  **/
  @javax.annotation.Nullable
  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }

  public void setUpdatedAt(OffsetDateTime updatedAt) {
    this.updatedAt = updatedAt;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RegistrarApiDomains registrarApiDomains = (RegistrarApiDomains) o;
    return Objects.equals(this.available, registrarApiDomains.available) &&
        Objects.equals(this.canRegister, registrarApiDomains.canRegister) &&
        Objects.equals(this.createdAt, registrarApiDomains.createdAt) &&
        Objects.equals(this.currentRegistrar, registrarApiDomains.currentRegistrar) &&
        Objects.equals(this.expiresAt, registrarApiDomains.expiresAt) &&
        Objects.equals(this.id, registrarApiDomains.id) &&
        Objects.equals(this.locked, registrarApiDomains.locked) &&
        Objects.equals(this.registrantContact, registrarApiDomains.registrantContact) &&
        Objects.equals(this.registryStatuses, registrarApiDomains.registryStatuses) &&
        Objects.equals(this.supportedTld, registrarApiDomains.supportedTld) &&
        Objects.equals(this.transferIn, registrarApiDomains.transferIn) &&
        Objects.equals(this.updatedAt, registrarApiDomains.updatedAt);
  }

  @Override
  public int hashCode() {
    return Objects.hash(available, canRegister, createdAt, currentRegistrar, expiresAt, id, locked, registrantContact, registryStatuses, supportedTld, transferIn, updatedAt);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RegistrarApiDomains {\n");
    sb.append("    available: ").append(toIndentedString(available)).append("\n");
    sb.append("    canRegister: ").append(toIndentedString(canRegister)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    currentRegistrar: ").append(toIndentedString(currentRegistrar)).append("\n");
    sb.append("    expiresAt: ").append(toIndentedString(expiresAt)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    locked: ").append(toIndentedString(locked)).append("\n");
    sb.append("    registrantContact: ").append(toIndentedString(registrantContact)).append("\n");
    sb.append("    registryStatuses: ").append(toIndentedString(registryStatuses)).append("\n");
    sb.append("    supportedTld: ").append(toIndentedString(supportedTld)).append("\n");
    sb.append("    transferIn: ").append(toIndentedString(transferIn)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("available");
    openapiFields.add("can_register");
    openapiFields.add("created_at");
    openapiFields.add("current_registrar");
    openapiFields.add("expires_at");
    openapiFields.add("id");
    openapiFields.add("locked");
    openapiFields.add("registrant_contact");
    openapiFields.add("registry_statuses");
    openapiFields.add("supported_tld");
    openapiFields.add("transfer_in");
    openapiFields.add("updated_at");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to RegistrarApiDomains
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RegistrarApiDomains.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RegistrarApiDomains is not found in the empty JSON string", RegistrarApiDomains.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RegistrarApiDomains.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RegistrarApiDomains` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("current_registrar") != null && !jsonObj.get("current_registrar").isJsonNull()) && !jsonObj.get("current_registrar").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `current_registrar` to be a primitive type in the JSON string but got `%s`", jsonObj.get("current_registrar").toString()));
      }
      if ((jsonObj.get("id") != null && !jsonObj.get("id").isJsonNull()) && !jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // validate the optional field `registrant_contact`
      if (jsonObj.get("registrant_contact") != null && !jsonObj.get("registrant_contact").isJsonNull()) {
        RegistrarApiRegistrantContact.validateJsonElement(jsonObj.get("registrant_contact"));
      }
      if ((jsonObj.get("registry_statuses") != null && !jsonObj.get("registry_statuses").isJsonNull()) && !jsonObj.get("registry_statuses").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `registry_statuses` to be a primitive type in the JSON string but got `%s`", jsonObj.get("registry_statuses").toString()));
      }
      // validate the optional field `transfer_in`
      if (jsonObj.get("transfer_in") != null && !jsonObj.get("transfer_in").isJsonNull()) {
        RegistrarApiTransferIn.validateJsonElement(jsonObj.get("transfer_in"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RegistrarApiDomains.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RegistrarApiDomains' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RegistrarApiDomains> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RegistrarApiDomains.class));

       return (TypeAdapter<T>) new TypeAdapter<RegistrarApiDomains>() {
           @Override
           public void write(JsonWriter out, RegistrarApiDomains value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RegistrarApiDomains read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of RegistrarApiDomains given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of RegistrarApiDomains
  * @throws IOException if the JSON string is invalid with respect to RegistrarApiDomains
  */
  public static RegistrarApiDomains fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RegistrarApiDomains.class);
  }

 /**
  * Convert an instance of RegistrarApiDomains to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

