/*
 * Cloudflare API
 * To get started using Cloudflare's products and services via the API, refer to [how to interact with Cloudflare](https://developers.cloudflare.com/fundamentals/basic-tasks/interact-with-cloudflare/), which covers using tools like [Terraform](https://developers.cloudflare.com/terraform/#cloudflare-terraform) and the [official SDKs](https://developers.cloudflare.com/fundamentals/api/reference/sdks/) to maintain your Cloudflare resources.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * The version of the OpenAPI document: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import invalidPackageName.JSON;

/**
 * Configures attributes for session affinity.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-04-22T11:29:23.936635354+01:00[Europe/London]", comments = "Generator version: 7.5.0")
public class LoadBalancingSessionAffinityAttributes {
  public static final String SERIALIZED_NAME_DRAIN_DURATION = "drain_duration";
  @SerializedName(SERIALIZED_NAME_DRAIN_DURATION)
  private BigDecimal drainDuration;

  public static final String SERIALIZED_NAME_HEADERS = "headers";
  @SerializedName(SERIALIZED_NAME_HEADERS)
  private Set<String> headers = new LinkedHashSet<>();

  public static final String SERIALIZED_NAME_REQUIRE_ALL_HEADERS = "require_all_headers";
  @SerializedName(SERIALIZED_NAME_REQUIRE_ALL_HEADERS)
  private Boolean requireAllHeaders = false;

  /**
   * Configures the SameSite attribute on session affinity cookie. Value \&quot;Auto\&quot; will be translated to \&quot;Lax\&quot; or \&quot;None\&quot; depending if Always Use HTTPS is enabled. Note: when using value \&quot;None\&quot;, the secure attribute can not be set to \&quot;Never\&quot;.
   */
  @JsonAdapter(SamesiteEnum.Adapter.class)
  public enum SamesiteEnum {
    AUTO("Auto"),
    
    LAX("Lax"),
    
    NONE("None"),
    
    STRICT("Strict");

    private String value;

    SamesiteEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SamesiteEnum fromValue(String value) {
      for (SamesiteEnum b : SamesiteEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SamesiteEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SamesiteEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SamesiteEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SamesiteEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SamesiteEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SAMESITE = "samesite";
  @SerializedName(SERIALIZED_NAME_SAMESITE)
  private SamesiteEnum samesite = SamesiteEnum.AUTO;

  /**
   * Configures the Secure attribute on session affinity cookie. Value \&quot;Always\&quot; indicates the Secure attribute will be set in the Set-Cookie header, \&quot;Never\&quot; indicates the Secure attribute will not be set, and \&quot;Auto\&quot; will set the Secure attribute depending if Always Use HTTPS is enabled.
   */
  @JsonAdapter(SecureEnum.Adapter.class)
  public enum SecureEnum {
    AUTO("Auto"),
    
    ALWAYS("Always"),
    
    NEVER("Never");

    private String value;

    SecureEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SecureEnum fromValue(String value) {
      for (SecureEnum b : SecureEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SecureEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SecureEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SecureEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SecureEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SecureEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SECURE = "secure";
  @SerializedName(SERIALIZED_NAME_SECURE)
  private SecureEnum secure = SecureEnum.AUTO;

  /**
   * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are: - &#x60;\&quot;none\&quot;&#x60;: No failover takes place for sessions pinned to the origin (default). - &#x60;\&quot;temporary\&quot;&#x60;: Traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. - &#x60;\&quot;sticky\&quot;&#x60;: The session affinity cookie is updated and subsequent requests are sent to the new origin. Note: Zero-downtime failover with sticky sessions is currently not supported for session affinity by header.
   */
  @JsonAdapter(ZeroDowntimeFailoverEnum.Adapter.class)
  public enum ZeroDowntimeFailoverEnum {
    NONE("none"),
    
    TEMPORARY("temporary"),
    
    STICKY("sticky");

    private String value;

    ZeroDowntimeFailoverEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ZeroDowntimeFailoverEnum fromValue(String value) {
      for (ZeroDowntimeFailoverEnum b : ZeroDowntimeFailoverEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ZeroDowntimeFailoverEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ZeroDowntimeFailoverEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ZeroDowntimeFailoverEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ZeroDowntimeFailoverEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ZeroDowntimeFailoverEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_ZERO_DOWNTIME_FAILOVER = "zero_downtime_failover";
  @SerializedName(SERIALIZED_NAME_ZERO_DOWNTIME_FAILOVER)
  private ZeroDowntimeFailoverEnum zeroDowntimeFailover = ZeroDowntimeFailoverEnum.NONE;

  public LoadBalancingSessionAffinityAttributes() {
  }

  public LoadBalancingSessionAffinityAttributes drainDuration(BigDecimal drainDuration) {
    this.drainDuration = drainDuration;
    return this;
  }

   /**
   * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
   * @return drainDuration
  **/
  @javax.annotation.Nullable
  public BigDecimal getDrainDuration() {
    return drainDuration;
  }

  public void setDrainDuration(BigDecimal drainDuration) {
    this.drainDuration = drainDuration;
  }


  public LoadBalancingSessionAffinityAttributes headers(Set<String> headers) {
    this.headers = headers;
    return this;
  }

  public LoadBalancingSessionAffinityAttributes addHeadersItem(String headersItem) {
    if (this.headers == null) {
      this.headers = new LinkedHashSet<>();
    }
    this.headers.add(headersItem);
    return this;
  }

   /**
   * Configures the names of HTTP headers to base session affinity on when header &#x60;session_affinity&#x60; is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: &#x60;\&quot;cookie:&lt;cookie-name-1&gt;,&lt;cookie-name-2&gt;\&quot;&#x60; (example) where everything after the colon is a comma-separated list of cookie names. Providing only &#x60;\&quot;cookie\&quot;&#x60; will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
   * @return headers
  **/
  @javax.annotation.Nullable
  public Set<String> getHeaders() {
    return headers;
  }

  public void setHeaders(Set<String> headers) {
    this.headers = headers;
  }


  public LoadBalancingSessionAffinityAttributes requireAllHeaders(Boolean requireAllHeaders) {
    this.requireAllHeaders = requireAllHeaders;
    return this;
  }

   /**
   * When header &#x60;session_affinity&#x60; is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are: - &#x60;\&quot;true\&quot;&#x60;: Load balancing requests must contain *all* of the HTTP headers specified by the &#x60;headers&#x60; session affinity attribute, otherwise sessions aren&#39;t created. - &#x60;\&quot;false\&quot;&#x60;: Load balancing requests must contain *at least one* of the HTTP headers specified by the &#x60;headers&#x60; session affinity attribute, otherwise sessions aren&#39;t created.
   * @return requireAllHeaders
  **/
  @javax.annotation.Nullable
  public Boolean getRequireAllHeaders() {
    return requireAllHeaders;
  }

  public void setRequireAllHeaders(Boolean requireAllHeaders) {
    this.requireAllHeaders = requireAllHeaders;
  }


  public LoadBalancingSessionAffinityAttributes samesite(SamesiteEnum samesite) {
    this.samesite = samesite;
    return this;
  }

   /**
   * Configures the SameSite attribute on session affinity cookie. Value \&quot;Auto\&quot; will be translated to \&quot;Lax\&quot; or \&quot;None\&quot; depending if Always Use HTTPS is enabled. Note: when using value \&quot;None\&quot;, the secure attribute can not be set to \&quot;Never\&quot;.
   * @return samesite
  **/
  @javax.annotation.Nullable
  public SamesiteEnum getSamesite() {
    return samesite;
  }

  public void setSamesite(SamesiteEnum samesite) {
    this.samesite = samesite;
  }


  public LoadBalancingSessionAffinityAttributes secure(SecureEnum secure) {
    this.secure = secure;
    return this;
  }

   /**
   * Configures the Secure attribute on session affinity cookie. Value \&quot;Always\&quot; indicates the Secure attribute will be set in the Set-Cookie header, \&quot;Never\&quot; indicates the Secure attribute will not be set, and \&quot;Auto\&quot; will set the Secure attribute depending if Always Use HTTPS is enabled.
   * @return secure
  **/
  @javax.annotation.Nullable
  public SecureEnum getSecure() {
    return secure;
  }

  public void setSecure(SecureEnum secure) {
    this.secure = secure;
  }


  public LoadBalancingSessionAffinityAttributes zeroDowntimeFailover(ZeroDowntimeFailoverEnum zeroDowntimeFailover) {
    this.zeroDowntimeFailover = zeroDowntimeFailover;
    return this;
  }

   /**
   * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are: - &#x60;\&quot;none\&quot;&#x60;: No failover takes place for sessions pinned to the origin (default). - &#x60;\&quot;temporary\&quot;&#x60;: Traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. - &#x60;\&quot;sticky\&quot;&#x60;: The session affinity cookie is updated and subsequent requests are sent to the new origin. Note: Zero-downtime failover with sticky sessions is currently not supported for session affinity by header.
   * @return zeroDowntimeFailover
  **/
  @javax.annotation.Nullable
  public ZeroDowntimeFailoverEnum getZeroDowntimeFailover() {
    return zeroDowntimeFailover;
  }

  public void setZeroDowntimeFailover(ZeroDowntimeFailoverEnum zeroDowntimeFailover) {
    this.zeroDowntimeFailover = zeroDowntimeFailover;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LoadBalancingSessionAffinityAttributes loadBalancingSessionAffinityAttributes = (LoadBalancingSessionAffinityAttributes) o;
    return Objects.equals(this.drainDuration, loadBalancingSessionAffinityAttributes.drainDuration) &&
        Objects.equals(this.headers, loadBalancingSessionAffinityAttributes.headers) &&
        Objects.equals(this.requireAllHeaders, loadBalancingSessionAffinityAttributes.requireAllHeaders) &&
        Objects.equals(this.samesite, loadBalancingSessionAffinityAttributes.samesite) &&
        Objects.equals(this.secure, loadBalancingSessionAffinityAttributes.secure) &&
        Objects.equals(this.zeroDowntimeFailover, loadBalancingSessionAffinityAttributes.zeroDowntimeFailover);
  }

  @Override
  public int hashCode() {
    return Objects.hash(drainDuration, headers, requireAllHeaders, samesite, secure, zeroDowntimeFailover);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LoadBalancingSessionAffinityAttributes {\n");
    sb.append("    drainDuration: ").append(toIndentedString(drainDuration)).append("\n");
    sb.append("    headers: ").append(toIndentedString(headers)).append("\n");
    sb.append("    requireAllHeaders: ").append(toIndentedString(requireAllHeaders)).append("\n");
    sb.append("    samesite: ").append(toIndentedString(samesite)).append("\n");
    sb.append("    secure: ").append(toIndentedString(secure)).append("\n");
    sb.append("    zeroDowntimeFailover: ").append(toIndentedString(zeroDowntimeFailover)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("drain_duration");
    openapiFields.add("headers");
    openapiFields.add("require_all_headers");
    openapiFields.add("samesite");
    openapiFields.add("secure");
    openapiFields.add("zero_downtime_failover");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to LoadBalancingSessionAffinityAttributes
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!LoadBalancingSessionAffinityAttributes.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in LoadBalancingSessionAffinityAttributes is not found in the empty JSON string", LoadBalancingSessionAffinityAttributes.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!LoadBalancingSessionAffinityAttributes.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `LoadBalancingSessionAffinityAttributes` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("headers") != null && !jsonObj.get("headers").isJsonNull() && !jsonObj.get("headers").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `headers` to be an array in the JSON string but got `%s`", jsonObj.get("headers").toString()));
      }
      if ((jsonObj.get("samesite") != null && !jsonObj.get("samesite").isJsonNull()) && !jsonObj.get("samesite").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `samesite` to be a primitive type in the JSON string but got `%s`", jsonObj.get("samesite").toString()));
      }
      // validate the optional field `samesite`
      if (jsonObj.get("samesite") != null && !jsonObj.get("samesite").isJsonNull()) {
        SamesiteEnum.validateJsonElement(jsonObj.get("samesite"));
      }
      if ((jsonObj.get("secure") != null && !jsonObj.get("secure").isJsonNull()) && !jsonObj.get("secure").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `secure` to be a primitive type in the JSON string but got `%s`", jsonObj.get("secure").toString()));
      }
      // validate the optional field `secure`
      if (jsonObj.get("secure") != null && !jsonObj.get("secure").isJsonNull()) {
        SecureEnum.validateJsonElement(jsonObj.get("secure"));
      }
      if ((jsonObj.get("zero_downtime_failover") != null && !jsonObj.get("zero_downtime_failover").isJsonNull()) && !jsonObj.get("zero_downtime_failover").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `zero_downtime_failover` to be a primitive type in the JSON string but got `%s`", jsonObj.get("zero_downtime_failover").toString()));
      }
      // validate the optional field `zero_downtime_failover`
      if (jsonObj.get("zero_downtime_failover") != null && !jsonObj.get("zero_downtime_failover").isJsonNull()) {
        ZeroDowntimeFailoverEnum.validateJsonElement(jsonObj.get("zero_downtime_failover"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!LoadBalancingSessionAffinityAttributes.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'LoadBalancingSessionAffinityAttributes' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<LoadBalancingSessionAffinityAttributes> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(LoadBalancingSessionAffinityAttributes.class));

       return (TypeAdapter<T>) new TypeAdapter<LoadBalancingSessionAffinityAttributes>() {
           @Override
           public void write(JsonWriter out, LoadBalancingSessionAffinityAttributes value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public LoadBalancingSessionAffinityAttributes read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of LoadBalancingSessionAffinityAttributes given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of LoadBalancingSessionAffinityAttributes
  * @throws IOException if the JSON string is invalid with respect to LoadBalancingSessionAffinityAttributes
  */
  public static LoadBalancingSessionAffinityAttributes fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, LoadBalancingSessionAffinityAttributes.class);
  }

 /**
  * Convert an instance of LoadBalancingSessionAffinityAttributes to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

