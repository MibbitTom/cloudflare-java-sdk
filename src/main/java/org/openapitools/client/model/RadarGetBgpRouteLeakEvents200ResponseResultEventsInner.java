/*
 * Cloudflare API
 * To get started using Cloudflare's products and services via the API, refer to [how to interact with Cloudflare](https://developers.cloudflare.com/fundamentals/basic-tasks/interact-with-cloudflare/), which covers using tools like [Terraform](https://developers.cloudflare.com/terraform/#cloudflare-terraform) and the [official SDKs](https://developers.cloudflare.com/fundamentals/api/reference/sdks/) to maintain your Cloudflare resources.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * The version of the OpenAPI document: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import invalidPackageName.JSON;

/**
 * RadarGetBgpRouteLeakEvents200ResponseResultEventsInner
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-04-22T11:29:23.936635354+01:00[Europe/London]", comments = "Generator version: 7.5.0")
public class RadarGetBgpRouteLeakEvents200ResponseResultEventsInner {
  public static final String SERIALIZED_NAME_COUNTRIES = "countries";
  @SerializedName(SERIALIZED_NAME_COUNTRIES)
  private List<String> countries = new ArrayList<>();

  public static final String SERIALIZED_NAME_DETECTED_TS = "detected_ts";
  @SerializedName(SERIALIZED_NAME_DETECTED_TS)
  private String detectedTs;

  public static final String SERIALIZED_NAME_FINISHED = "finished";
  @SerializedName(SERIALIZED_NAME_FINISHED)
  private Boolean finished;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  private Integer id;

  public static final String SERIALIZED_NAME_LEAK_ASN = "leak_asn";
  @SerializedName(SERIALIZED_NAME_LEAK_ASN)
  private Integer leakAsn;

  public static final String SERIALIZED_NAME_LEAK_COUNT = "leak_count";
  @SerializedName(SERIALIZED_NAME_LEAK_COUNT)
  private Integer leakCount;

  public static final String SERIALIZED_NAME_LEAK_SEG = "leak_seg";
  @SerializedName(SERIALIZED_NAME_LEAK_SEG)
  private List<Integer> leakSeg = new ArrayList<>();

  public static final String SERIALIZED_NAME_LEAK_TYPE = "leak_type";
  @SerializedName(SERIALIZED_NAME_LEAK_TYPE)
  private Integer leakType;

  public static final String SERIALIZED_NAME_MAX_TS = "max_ts";
  @SerializedName(SERIALIZED_NAME_MAX_TS)
  private String maxTs;

  public static final String SERIALIZED_NAME_MIN_TS = "min_ts";
  @SerializedName(SERIALIZED_NAME_MIN_TS)
  private String minTs;

  public static final String SERIALIZED_NAME_ORIGIN_COUNT = "origin_count";
  @SerializedName(SERIALIZED_NAME_ORIGIN_COUNT)
  private Integer originCount;

  public static final String SERIALIZED_NAME_PEER_COUNT = "peer_count";
  @SerializedName(SERIALIZED_NAME_PEER_COUNT)
  private Integer peerCount;

  public static final String SERIALIZED_NAME_PREFIX_COUNT = "prefix_count";
  @SerializedName(SERIALIZED_NAME_PREFIX_COUNT)
  private Integer prefixCount;

  public RadarGetBgpRouteLeakEvents200ResponseResultEventsInner() {
  }

  public RadarGetBgpRouteLeakEvents200ResponseResultEventsInner countries(List<String> countries) {
    this.countries = countries;
    return this;
  }

  public RadarGetBgpRouteLeakEvents200ResponseResultEventsInner addCountriesItem(String countriesItem) {
    if (this.countries == null) {
      this.countries = new ArrayList<>();
    }
    this.countries.add(countriesItem);
    return this;
  }

   /**
   * Get countries
   * @return countries
  **/
  @javax.annotation.Nonnull
  public List<String> getCountries() {
    return countries;
  }

  public void setCountries(List<String> countries) {
    this.countries = countries;
  }


  public RadarGetBgpRouteLeakEvents200ResponseResultEventsInner detectedTs(String detectedTs) {
    this.detectedTs = detectedTs;
    return this;
  }

   /**
   * Get detectedTs
   * @return detectedTs
  **/
  @javax.annotation.Nonnull
  public String getDetectedTs() {
    return detectedTs;
  }

  public void setDetectedTs(String detectedTs) {
    this.detectedTs = detectedTs;
  }


  public RadarGetBgpRouteLeakEvents200ResponseResultEventsInner finished(Boolean finished) {
    this.finished = finished;
    return this;
  }

   /**
   * Get finished
   * @return finished
  **/
  @javax.annotation.Nonnull
  public Boolean getFinished() {
    return finished;
  }

  public void setFinished(Boolean finished) {
    this.finished = finished;
  }


  public RadarGetBgpRouteLeakEvents200ResponseResultEventsInner id(Integer id) {
    this.id = id;
    return this;
  }

   /**
   * Get id
   * @return id
  **/
  @javax.annotation.Nonnull
  public Integer getId() {
    return id;
  }

  public void setId(Integer id) {
    this.id = id;
  }


  public RadarGetBgpRouteLeakEvents200ResponseResultEventsInner leakAsn(Integer leakAsn) {
    this.leakAsn = leakAsn;
    return this;
  }

   /**
   * Get leakAsn
   * @return leakAsn
  **/
  @javax.annotation.Nonnull
  public Integer getLeakAsn() {
    return leakAsn;
  }

  public void setLeakAsn(Integer leakAsn) {
    this.leakAsn = leakAsn;
  }


  public RadarGetBgpRouteLeakEvents200ResponseResultEventsInner leakCount(Integer leakCount) {
    this.leakCount = leakCount;
    return this;
  }

   /**
   * Get leakCount
   * @return leakCount
  **/
  @javax.annotation.Nonnull
  public Integer getLeakCount() {
    return leakCount;
  }

  public void setLeakCount(Integer leakCount) {
    this.leakCount = leakCount;
  }


  public RadarGetBgpRouteLeakEvents200ResponseResultEventsInner leakSeg(List<Integer> leakSeg) {
    this.leakSeg = leakSeg;
    return this;
  }

  public RadarGetBgpRouteLeakEvents200ResponseResultEventsInner addLeakSegItem(Integer leakSegItem) {
    if (this.leakSeg == null) {
      this.leakSeg = new ArrayList<>();
    }
    this.leakSeg.add(leakSegItem);
    return this;
  }

   /**
   * Get leakSeg
   * @return leakSeg
  **/
  @javax.annotation.Nonnull
  public List<Integer> getLeakSeg() {
    return leakSeg;
  }

  public void setLeakSeg(List<Integer> leakSeg) {
    this.leakSeg = leakSeg;
  }


  public RadarGetBgpRouteLeakEvents200ResponseResultEventsInner leakType(Integer leakType) {
    this.leakType = leakType;
    return this;
  }

   /**
   * Get leakType
   * @return leakType
  **/
  @javax.annotation.Nonnull
  public Integer getLeakType() {
    return leakType;
  }

  public void setLeakType(Integer leakType) {
    this.leakType = leakType;
  }


  public RadarGetBgpRouteLeakEvents200ResponseResultEventsInner maxTs(String maxTs) {
    this.maxTs = maxTs;
    return this;
  }

   /**
   * Get maxTs
   * @return maxTs
  **/
  @javax.annotation.Nonnull
  public String getMaxTs() {
    return maxTs;
  }

  public void setMaxTs(String maxTs) {
    this.maxTs = maxTs;
  }


  public RadarGetBgpRouteLeakEvents200ResponseResultEventsInner minTs(String minTs) {
    this.minTs = minTs;
    return this;
  }

   /**
   * Get minTs
   * @return minTs
  **/
  @javax.annotation.Nonnull
  public String getMinTs() {
    return minTs;
  }

  public void setMinTs(String minTs) {
    this.minTs = minTs;
  }


  public RadarGetBgpRouteLeakEvents200ResponseResultEventsInner originCount(Integer originCount) {
    this.originCount = originCount;
    return this;
  }

   /**
   * Get originCount
   * @return originCount
  **/
  @javax.annotation.Nonnull
  public Integer getOriginCount() {
    return originCount;
  }

  public void setOriginCount(Integer originCount) {
    this.originCount = originCount;
  }


  public RadarGetBgpRouteLeakEvents200ResponseResultEventsInner peerCount(Integer peerCount) {
    this.peerCount = peerCount;
    return this;
  }

   /**
   * Get peerCount
   * @return peerCount
  **/
  @javax.annotation.Nonnull
  public Integer getPeerCount() {
    return peerCount;
  }

  public void setPeerCount(Integer peerCount) {
    this.peerCount = peerCount;
  }


  public RadarGetBgpRouteLeakEvents200ResponseResultEventsInner prefixCount(Integer prefixCount) {
    this.prefixCount = prefixCount;
    return this;
  }

   /**
   * Get prefixCount
   * @return prefixCount
  **/
  @javax.annotation.Nonnull
  public Integer getPrefixCount() {
    return prefixCount;
  }

  public void setPrefixCount(Integer prefixCount) {
    this.prefixCount = prefixCount;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RadarGetBgpRouteLeakEvents200ResponseResultEventsInner radarGetBgpRouteLeakEvents200ResponseResultEventsInner = (RadarGetBgpRouteLeakEvents200ResponseResultEventsInner) o;
    return Objects.equals(this.countries, radarGetBgpRouteLeakEvents200ResponseResultEventsInner.countries) &&
        Objects.equals(this.detectedTs, radarGetBgpRouteLeakEvents200ResponseResultEventsInner.detectedTs) &&
        Objects.equals(this.finished, radarGetBgpRouteLeakEvents200ResponseResultEventsInner.finished) &&
        Objects.equals(this.id, radarGetBgpRouteLeakEvents200ResponseResultEventsInner.id) &&
        Objects.equals(this.leakAsn, radarGetBgpRouteLeakEvents200ResponseResultEventsInner.leakAsn) &&
        Objects.equals(this.leakCount, radarGetBgpRouteLeakEvents200ResponseResultEventsInner.leakCount) &&
        Objects.equals(this.leakSeg, radarGetBgpRouteLeakEvents200ResponseResultEventsInner.leakSeg) &&
        Objects.equals(this.leakType, radarGetBgpRouteLeakEvents200ResponseResultEventsInner.leakType) &&
        Objects.equals(this.maxTs, radarGetBgpRouteLeakEvents200ResponseResultEventsInner.maxTs) &&
        Objects.equals(this.minTs, radarGetBgpRouteLeakEvents200ResponseResultEventsInner.minTs) &&
        Objects.equals(this.originCount, radarGetBgpRouteLeakEvents200ResponseResultEventsInner.originCount) &&
        Objects.equals(this.peerCount, radarGetBgpRouteLeakEvents200ResponseResultEventsInner.peerCount) &&
        Objects.equals(this.prefixCount, radarGetBgpRouteLeakEvents200ResponseResultEventsInner.prefixCount);
  }

  @Override
  public int hashCode() {
    return Objects.hash(countries, detectedTs, finished, id, leakAsn, leakCount, leakSeg, leakType, maxTs, minTs, originCount, peerCount, prefixCount);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RadarGetBgpRouteLeakEvents200ResponseResultEventsInner {\n");
    sb.append("    countries: ").append(toIndentedString(countries)).append("\n");
    sb.append("    detectedTs: ").append(toIndentedString(detectedTs)).append("\n");
    sb.append("    finished: ").append(toIndentedString(finished)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    leakAsn: ").append(toIndentedString(leakAsn)).append("\n");
    sb.append("    leakCount: ").append(toIndentedString(leakCount)).append("\n");
    sb.append("    leakSeg: ").append(toIndentedString(leakSeg)).append("\n");
    sb.append("    leakType: ").append(toIndentedString(leakType)).append("\n");
    sb.append("    maxTs: ").append(toIndentedString(maxTs)).append("\n");
    sb.append("    minTs: ").append(toIndentedString(minTs)).append("\n");
    sb.append("    originCount: ").append(toIndentedString(originCount)).append("\n");
    sb.append("    peerCount: ").append(toIndentedString(peerCount)).append("\n");
    sb.append("    prefixCount: ").append(toIndentedString(prefixCount)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("countries");
    openapiFields.add("detected_ts");
    openapiFields.add("finished");
    openapiFields.add("id");
    openapiFields.add("leak_asn");
    openapiFields.add("leak_count");
    openapiFields.add("leak_seg");
    openapiFields.add("leak_type");
    openapiFields.add("max_ts");
    openapiFields.add("min_ts");
    openapiFields.add("origin_count");
    openapiFields.add("peer_count");
    openapiFields.add("prefix_count");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("countries");
    openapiRequiredFields.add("detected_ts");
    openapiRequiredFields.add("finished");
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("leak_asn");
    openapiRequiredFields.add("leak_count");
    openapiRequiredFields.add("leak_seg");
    openapiRequiredFields.add("leak_type");
    openapiRequiredFields.add("max_ts");
    openapiRequiredFields.add("min_ts");
    openapiRequiredFields.add("origin_count");
    openapiRequiredFields.add("peer_count");
    openapiRequiredFields.add("prefix_count");
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to RadarGetBgpRouteLeakEvents200ResponseResultEventsInner
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!RadarGetBgpRouteLeakEvents200ResponseResultEventsInner.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in RadarGetBgpRouteLeakEvents200ResponseResultEventsInner is not found in the empty JSON string", RadarGetBgpRouteLeakEvents200ResponseResultEventsInner.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!RadarGetBgpRouteLeakEvents200ResponseResultEventsInner.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `RadarGetBgpRouteLeakEvents200ResponseResultEventsInner` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : RadarGetBgpRouteLeakEvents200ResponseResultEventsInner.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the required json array is present
      if (jsonObj.get("countries") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("countries").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `countries` to be an array in the JSON string but got `%s`", jsonObj.get("countries").toString()));
      }
      if (!jsonObj.get("detected_ts").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `detected_ts` to be a primitive type in the JSON string but got `%s`", jsonObj.get("detected_ts").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("leak_seg") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("leak_seg").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `leak_seg` to be an array in the JSON string but got `%s`", jsonObj.get("leak_seg").toString()));
      }
      if (!jsonObj.get("max_ts").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `max_ts` to be a primitive type in the JSON string but got `%s`", jsonObj.get("max_ts").toString()));
      }
      if (!jsonObj.get("min_ts").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `min_ts` to be a primitive type in the JSON string but got `%s`", jsonObj.get("min_ts").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!RadarGetBgpRouteLeakEvents200ResponseResultEventsInner.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'RadarGetBgpRouteLeakEvents200ResponseResultEventsInner' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<RadarGetBgpRouteLeakEvents200ResponseResultEventsInner> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(RadarGetBgpRouteLeakEvents200ResponseResultEventsInner.class));

       return (TypeAdapter<T>) new TypeAdapter<RadarGetBgpRouteLeakEvents200ResponseResultEventsInner>() {
           @Override
           public void write(JsonWriter out, RadarGetBgpRouteLeakEvents200ResponseResultEventsInner value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public RadarGetBgpRouteLeakEvents200ResponseResultEventsInner read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of RadarGetBgpRouteLeakEvents200ResponseResultEventsInner given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of RadarGetBgpRouteLeakEvents200ResponseResultEventsInner
  * @throws IOException if the JSON string is invalid with respect to RadarGetBgpRouteLeakEvents200ResponseResultEventsInner
  */
  public static RadarGetBgpRouteLeakEvents200ResponseResultEventsInner fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, RadarGetBgpRouteLeakEvents200ResponseResultEventsInner.class);
  }

 /**
  * Convert an instance of RadarGetBgpRouteLeakEvents200ResponseResultEventsInner to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

