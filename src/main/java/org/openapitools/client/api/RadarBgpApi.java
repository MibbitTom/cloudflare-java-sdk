/*
 * Cloudflare API
 * To get started using Cloudflare's products and services via the API, refer to [how to interact with Cloudflare](https://developers.cloudflare.com/fundamentals/basic-tasks/interact-with-cloudflare/), which covers using tools like [Terraform](https://developers.cloudflare.com/terraform/#cloudflare-terraform) and the [official SDKs](https://developers.cloudflare.com/fundamentals/api/reference/sdks/) to maintain your Cloudflare resources.  Using the Cloudflare API requires authentication so that Cloudflare knows who is making requests and what permissions you have. Create an API token to grant access to the API to perform actions.  To create an API token, from the Cloudflare dashboard, go to My Profile > API Tokens and select Create Token. For more information on how to create and troubleshoot API tokens, refer to our [API fundamentals](https://developers.cloudflare.com/fundamentals/api/).  Totally new to Cloudflare? [Start here](https://developers.cloudflare.com/fundamentals/get-started/).
 *
 * The version of the OpenAPI document: 4.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import java.time.OffsetDateTime;
import org.openapitools.client.model.RadarGetBgpHijacksEvents200Response;
import org.openapitools.client.model.RadarGetBgpIpSpaceTimeseries200Response;
import org.openapitools.client.model.RadarGetBgpPfx2as200Response;
import org.openapitools.client.model.RadarGetBgpPfx2asMoas200Response;
import org.openapitools.client.model.RadarGetBgpRouteLeakEvents200Response;
import org.openapitools.client.model.RadarGetBgpRoutesStats200Response;
import org.openapitools.client.model.RadarGetBgpTopAses200Response;
import org.openapitools.client.model.RadarGetBgpTopAsnsByPrefixes200Response;
import org.openapitools.client.model.RadarGetBgpTopPrefixes200Response;
import org.openapitools.client.model.RadarGetDnsAs112Timeseries200Response;
import org.openapitools.client.model.RadarGetDnsAs112TopLocations404Response;
import org.openapitools.client.model.WorkersAiListFinetunes400Response;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class RadarBgpApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public RadarBgpApi() {
        this(Configuration.getDefaultApiClient());
    }

    public RadarBgpApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for radarGetBgpHijacksEvents
     * @param page  (optional)
     * @param perPage  (optional)
     * @param eventId  (optional)
     * @param hijackerAsn  (optional)
     * @param victimAsn  (optional)
     * @param involvedAsn  (optional)
     * @param involvedCountry  (optional)
     * @param prefix  (optional)
     * @param minConfidence  (optional)
     * @param maxConfidence  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param sortBy  (optional)
     * @param sortOrder  (optional)
     * @param format  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpHijacksEventsCall(Integer page, Integer perPage, Integer eventId, Integer hijackerAsn, Integer victimAsn, Integer involvedAsn, String involvedCountry, String prefix, Integer minConfidence, Integer maxConfidence, String dateRange, OffsetDateTime dateStart, OffsetDateTime dateEnd, String sortBy, String sortOrder, String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/radar/bgp/hijacks/events";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (eventId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("eventId", eventId));
        }

        if (hijackerAsn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("hijackerAsn", hijackerAsn));
        }

        if (victimAsn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("victimAsn", victimAsn));
        }

        if (involvedAsn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("involvedAsn", involvedAsn));
        }

        if (involvedCountry != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("involvedCountry", involvedCountry));
        }

        if (prefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("prefix", prefix));
        }

        if (minConfidence != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("minConfidence", minConfidence));
        }

        if (maxConfidence != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("maxConfidence", maxConfidence));
        }

        if (dateRange != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("dateRange", dateRange));
        }

        if (dateStart != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("dateStart", dateStart));
        }

        if (dateEnd != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("dateEnd", dateEnd));
        }

        if (sortBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sortBy", sortBy));
        }

        if (sortOrder != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sortOrder", sortOrder));
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_token", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call radarGetBgpHijacksEventsValidateBeforeCall(Integer page, Integer perPage, Integer eventId, Integer hijackerAsn, Integer victimAsn, Integer involvedAsn, String involvedCountry, String prefix, Integer minConfidence, Integer maxConfidence, String dateRange, OffsetDateTime dateStart, OffsetDateTime dateEnd, String sortBy, String sortOrder, String format, final ApiCallback _callback) throws ApiException {
        return radarGetBgpHijacksEventsCall(page, perPage, eventId, hijackerAsn, victimAsn, involvedAsn, involvedCountry, prefix, minConfidence, maxConfidence, dateRange, dateStart, dateEnd, sortBy, sortOrder, format, _callback);

    }

    /**
     * Get BGP hijack events
     * Get the BGP hijack events. (Beta)
     * @param page  (optional)
     * @param perPage  (optional)
     * @param eventId  (optional)
     * @param hijackerAsn  (optional)
     * @param victimAsn  (optional)
     * @param involvedAsn  (optional)
     * @param involvedCountry  (optional)
     * @param prefix  (optional)
     * @param minConfidence  (optional)
     * @param maxConfidence  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param sortBy  (optional)
     * @param sortOrder  (optional)
     * @param format  (optional)
     * @return RadarGetBgpHijacksEvents200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public RadarGetBgpHijacksEvents200Response radarGetBgpHijacksEvents(Integer page, Integer perPage, Integer eventId, Integer hijackerAsn, Integer victimAsn, Integer involvedAsn, String involvedCountry, String prefix, Integer minConfidence, Integer maxConfidence, String dateRange, OffsetDateTime dateStart, OffsetDateTime dateEnd, String sortBy, String sortOrder, String format) throws ApiException {
        ApiResponse<RadarGetBgpHijacksEvents200Response> localVarResp = radarGetBgpHijacksEventsWithHttpInfo(page, perPage, eventId, hijackerAsn, victimAsn, involvedAsn, involvedCountry, prefix, minConfidence, maxConfidence, dateRange, dateStart, dateEnd, sortBy, sortOrder, format);
        return localVarResp.getData();
    }

    /**
     * Get BGP hijack events
     * Get the BGP hijack events. (Beta)
     * @param page  (optional)
     * @param perPage  (optional)
     * @param eventId  (optional)
     * @param hijackerAsn  (optional)
     * @param victimAsn  (optional)
     * @param involvedAsn  (optional)
     * @param involvedCountry  (optional)
     * @param prefix  (optional)
     * @param minConfidence  (optional)
     * @param maxConfidence  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param sortBy  (optional)
     * @param sortOrder  (optional)
     * @param format  (optional)
     * @return ApiResponse&lt;RadarGetBgpHijacksEvents200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RadarGetBgpHijacksEvents200Response> radarGetBgpHijacksEventsWithHttpInfo(Integer page, Integer perPage, Integer eventId, Integer hijackerAsn, Integer victimAsn, Integer involvedAsn, String involvedCountry, String prefix, Integer minConfidence, Integer maxConfidence, String dateRange, OffsetDateTime dateStart, OffsetDateTime dateEnd, String sortBy, String sortOrder, String format) throws ApiException {
        okhttp3.Call localVarCall = radarGetBgpHijacksEventsValidateBeforeCall(page, perPage, eventId, hijackerAsn, victimAsn, involvedAsn, involvedCountry, prefix, minConfidence, maxConfidence, dateRange, dateStart, dateEnd, sortBy, sortOrder, format, null);
        Type localVarReturnType = new TypeToken<RadarGetBgpHijacksEvents200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get BGP hijack events (asynchronously)
     * Get the BGP hijack events. (Beta)
     * @param page  (optional)
     * @param perPage  (optional)
     * @param eventId  (optional)
     * @param hijackerAsn  (optional)
     * @param victimAsn  (optional)
     * @param involvedAsn  (optional)
     * @param involvedCountry  (optional)
     * @param prefix  (optional)
     * @param minConfidence  (optional)
     * @param maxConfidence  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param sortBy  (optional)
     * @param sortOrder  (optional)
     * @param format  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpHijacksEventsAsync(Integer page, Integer perPage, Integer eventId, Integer hijackerAsn, Integer victimAsn, Integer involvedAsn, String involvedCountry, String prefix, Integer minConfidence, Integer maxConfidence, String dateRange, OffsetDateTime dateStart, OffsetDateTime dateEnd, String sortBy, String sortOrder, String format, final ApiCallback<RadarGetBgpHijacksEvents200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = radarGetBgpHijacksEventsValidateBeforeCall(page, perPage, eventId, hijackerAsn, victimAsn, involvedAsn, involvedCountry, prefix, minConfidence, maxConfidence, dateRange, dateStart, dateEnd, sortBy, sortOrder, format, _callback);
        Type localVarReturnType = new TypeToken<RadarGetBgpHijacksEvents200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for radarGetBgpIpSpaceTimeseries
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param asn  (optional)
     * @param location  (optional)
     * @param includeDelay  (optional)
     * @param format  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpIpSpaceTimeseriesCall(String dateRange, OffsetDateTime dateStart, OffsetDateTime dateEnd, Integer asn, String location, Boolean includeDelay, String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/radar/bgp/routes/timeseries";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dateRange != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("dateRange", dateRange));
        }

        if (dateStart != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("dateStart", dateStart));
        }

        if (dateEnd != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("dateEnd", dateEnd));
        }

        if (asn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asn", asn));
        }

        if (location != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("location", location));
        }

        if (includeDelay != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeDelay", includeDelay));
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_token", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call radarGetBgpIpSpaceTimeseriesValidateBeforeCall(String dateRange, OffsetDateTime dateStart, OffsetDateTime dateEnd, Integer asn, String location, Boolean includeDelay, String format, final ApiCallback _callback) throws ApiException {
        return radarGetBgpIpSpaceTimeseriesCall(dateRange, dateStart, dateEnd, asn, location, includeDelay, format, _callback);

    }

    /**
     * Get BGP IP space time series
     * Gets time-series data for the announced IP space count, represented as the number of IPv4 /24s and IPv6 /48s, for a given ASN.
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param asn  (optional)
     * @param location  (optional)
     * @param includeDelay  (optional)
     * @param format  (optional)
     * @return RadarGetBgpIpSpaceTimeseries200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public RadarGetBgpIpSpaceTimeseries200Response radarGetBgpIpSpaceTimeseries(String dateRange, OffsetDateTime dateStart, OffsetDateTime dateEnd, Integer asn, String location, Boolean includeDelay, String format) throws ApiException {
        ApiResponse<RadarGetBgpIpSpaceTimeseries200Response> localVarResp = radarGetBgpIpSpaceTimeseriesWithHttpInfo(dateRange, dateStart, dateEnd, asn, location, includeDelay, format);
        return localVarResp.getData();
    }

    /**
     * Get BGP IP space time series
     * Gets time-series data for the announced IP space count, represented as the number of IPv4 /24s and IPv6 /48s, for a given ASN.
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param asn  (optional)
     * @param location  (optional)
     * @param includeDelay  (optional)
     * @param format  (optional)
     * @return ApiResponse&lt;RadarGetBgpIpSpaceTimeseries200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RadarGetBgpIpSpaceTimeseries200Response> radarGetBgpIpSpaceTimeseriesWithHttpInfo(String dateRange, OffsetDateTime dateStart, OffsetDateTime dateEnd, Integer asn, String location, Boolean includeDelay, String format) throws ApiException {
        okhttp3.Call localVarCall = radarGetBgpIpSpaceTimeseriesValidateBeforeCall(dateRange, dateStart, dateEnd, asn, location, includeDelay, format, null);
        Type localVarReturnType = new TypeToken<RadarGetBgpIpSpaceTimeseries200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get BGP IP space time series (asynchronously)
     * Gets time-series data for the announced IP space count, represented as the number of IPv4 /24s and IPv6 /48s, for a given ASN.
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param asn  (optional)
     * @param location  (optional)
     * @param includeDelay  (optional)
     * @param format  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpIpSpaceTimeseriesAsync(String dateRange, OffsetDateTime dateStart, OffsetDateTime dateEnd, Integer asn, String location, Boolean includeDelay, String format, final ApiCallback<RadarGetBgpIpSpaceTimeseries200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = radarGetBgpIpSpaceTimeseriesValidateBeforeCall(dateRange, dateStart, dateEnd, asn, location, includeDelay, format, _callback);
        Type localVarReturnType = new TypeToken<RadarGetBgpIpSpaceTimeseries200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for radarGetBgpPfx2as
     * @param origin  (optional)
     * @param prefix  (optional)
     * @param rpkiStatus  (optional)
     * @param longestPrefixMatch  (optional)
     * @param format  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpPfx2asCall(Integer origin, String prefix, String rpkiStatus, Boolean longestPrefixMatch, String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/radar/bgp/routes/pfx2as";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (origin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("origin", origin));
        }

        if (prefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("prefix", prefix));
        }

        if (rpkiStatus != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("rpkiStatus", rpkiStatus));
        }

        if (longestPrefixMatch != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("longestPrefixMatch", longestPrefixMatch));
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_token", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call radarGetBgpPfx2asValidateBeforeCall(Integer origin, String prefix, String rpkiStatus, Boolean longestPrefixMatch, String format, final ApiCallback _callback) throws ApiException {
        return radarGetBgpPfx2asCall(origin, prefix, rpkiStatus, longestPrefixMatch, format, _callback);

    }

    /**
     * Get prefix-to-ASN mapping
     * Lookup prefix-to-ASN mapping on global routing tables.
     * @param origin  (optional)
     * @param prefix  (optional)
     * @param rpkiStatus  (optional)
     * @param longestPrefixMatch  (optional)
     * @param format  (optional)
     * @return RadarGetBgpPfx2as200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public RadarGetBgpPfx2as200Response radarGetBgpPfx2as(Integer origin, String prefix, String rpkiStatus, Boolean longestPrefixMatch, String format) throws ApiException {
        ApiResponse<RadarGetBgpPfx2as200Response> localVarResp = radarGetBgpPfx2asWithHttpInfo(origin, prefix, rpkiStatus, longestPrefixMatch, format);
        return localVarResp.getData();
    }

    /**
     * Get prefix-to-ASN mapping
     * Lookup prefix-to-ASN mapping on global routing tables.
     * @param origin  (optional)
     * @param prefix  (optional)
     * @param rpkiStatus  (optional)
     * @param longestPrefixMatch  (optional)
     * @param format  (optional)
     * @return ApiResponse&lt;RadarGetBgpPfx2as200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RadarGetBgpPfx2as200Response> radarGetBgpPfx2asWithHttpInfo(Integer origin, String prefix, String rpkiStatus, Boolean longestPrefixMatch, String format) throws ApiException {
        okhttp3.Call localVarCall = radarGetBgpPfx2asValidateBeforeCall(origin, prefix, rpkiStatus, longestPrefixMatch, format, null);
        Type localVarReturnType = new TypeToken<RadarGetBgpPfx2as200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get prefix-to-ASN mapping (asynchronously)
     * Lookup prefix-to-ASN mapping on global routing tables.
     * @param origin  (optional)
     * @param prefix  (optional)
     * @param rpkiStatus  (optional)
     * @param longestPrefixMatch  (optional)
     * @param format  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpPfx2asAsync(Integer origin, String prefix, String rpkiStatus, Boolean longestPrefixMatch, String format, final ApiCallback<RadarGetBgpPfx2as200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = radarGetBgpPfx2asValidateBeforeCall(origin, prefix, rpkiStatus, longestPrefixMatch, format, _callback);
        Type localVarReturnType = new TypeToken<RadarGetBgpPfx2as200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for radarGetBgpPfx2asMoas
     * @param origin  (optional)
     * @param prefix  (optional)
     * @param invalidOnly  (optional)
     * @param format  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpPfx2asMoasCall(Integer origin, String prefix, Boolean invalidOnly, String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/radar/bgp/routes/moas";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (origin != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("origin", origin));
        }

        if (prefix != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("prefix", prefix));
        }

        if (invalidOnly != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("invalid_only", invalidOnly));
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_token", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call radarGetBgpPfx2asMoasValidateBeforeCall(Integer origin, String prefix, Boolean invalidOnly, String format, final ApiCallback _callback) throws ApiException {
        return radarGetBgpPfx2asMoasCall(origin, prefix, invalidOnly, format, _callback);

    }

    /**
     * Get MOASes
     * List all Multi-origin AS (MOAS) prefixes on the global routing tables.
     * @param origin  (optional)
     * @param prefix  (optional)
     * @param invalidOnly  (optional)
     * @param format  (optional)
     * @return RadarGetBgpPfx2asMoas200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public RadarGetBgpPfx2asMoas200Response radarGetBgpPfx2asMoas(Integer origin, String prefix, Boolean invalidOnly, String format) throws ApiException {
        ApiResponse<RadarGetBgpPfx2asMoas200Response> localVarResp = radarGetBgpPfx2asMoasWithHttpInfo(origin, prefix, invalidOnly, format);
        return localVarResp.getData();
    }

    /**
     * Get MOASes
     * List all Multi-origin AS (MOAS) prefixes on the global routing tables.
     * @param origin  (optional)
     * @param prefix  (optional)
     * @param invalidOnly  (optional)
     * @param format  (optional)
     * @return ApiResponse&lt;RadarGetBgpPfx2asMoas200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RadarGetBgpPfx2asMoas200Response> radarGetBgpPfx2asMoasWithHttpInfo(Integer origin, String prefix, Boolean invalidOnly, String format) throws ApiException {
        okhttp3.Call localVarCall = radarGetBgpPfx2asMoasValidateBeforeCall(origin, prefix, invalidOnly, format, null);
        Type localVarReturnType = new TypeToken<RadarGetBgpPfx2asMoas200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get MOASes (asynchronously)
     * List all Multi-origin AS (MOAS) prefixes on the global routing tables.
     * @param origin  (optional)
     * @param prefix  (optional)
     * @param invalidOnly  (optional)
     * @param format  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpPfx2asMoasAsync(Integer origin, String prefix, Boolean invalidOnly, String format, final ApiCallback<RadarGetBgpPfx2asMoas200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = radarGetBgpPfx2asMoasValidateBeforeCall(origin, prefix, invalidOnly, format, _callback);
        Type localVarReturnType = new TypeToken<RadarGetBgpPfx2asMoas200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for radarGetBgpRouteLeakEvents
     * @param page  (optional)
     * @param perPage  (optional)
     * @param eventId  (optional)
     * @param leakAsn  (optional)
     * @param involvedAsn  (optional)
     * @param involvedCountry  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param sortBy  (optional)
     * @param sortOrder  (optional)
     * @param format  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpRouteLeakEventsCall(Integer page, Integer perPage, Integer eventId, Integer leakAsn, Integer involvedAsn, String involvedCountry, String dateRange, OffsetDateTime dateStart, OffsetDateTime dateEnd, String sortBy, String sortOrder, String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/radar/bgp/leaks/events";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (perPage != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("per_page", perPage));
        }

        if (eventId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("eventId", eventId));
        }

        if (leakAsn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("leakAsn", leakAsn));
        }

        if (involvedAsn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("involvedAsn", involvedAsn));
        }

        if (involvedCountry != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("involvedCountry", involvedCountry));
        }

        if (dateRange != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("dateRange", dateRange));
        }

        if (dateStart != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("dateStart", dateStart));
        }

        if (dateEnd != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("dateEnd", dateEnd));
        }

        if (sortBy != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sortBy", sortBy));
        }

        if (sortOrder != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sortOrder", sortOrder));
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_token", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call radarGetBgpRouteLeakEventsValidateBeforeCall(Integer page, Integer perPage, Integer eventId, Integer leakAsn, Integer involvedAsn, String involvedCountry, String dateRange, OffsetDateTime dateStart, OffsetDateTime dateEnd, String sortBy, String sortOrder, String format, final ApiCallback _callback) throws ApiException {
        return radarGetBgpRouteLeakEventsCall(page, perPage, eventId, leakAsn, involvedAsn, involvedCountry, dateRange, dateStart, dateEnd, sortBy, sortOrder, format, _callback);

    }

    /**
     * Get BGP route leak events
     * Get the BGP route leak events (Beta).
     * @param page  (optional)
     * @param perPage  (optional)
     * @param eventId  (optional)
     * @param leakAsn  (optional)
     * @param involvedAsn  (optional)
     * @param involvedCountry  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param sortBy  (optional)
     * @param sortOrder  (optional)
     * @param format  (optional)
     * @return RadarGetBgpRouteLeakEvents200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public RadarGetBgpRouteLeakEvents200Response radarGetBgpRouteLeakEvents(Integer page, Integer perPage, Integer eventId, Integer leakAsn, Integer involvedAsn, String involvedCountry, String dateRange, OffsetDateTime dateStart, OffsetDateTime dateEnd, String sortBy, String sortOrder, String format) throws ApiException {
        ApiResponse<RadarGetBgpRouteLeakEvents200Response> localVarResp = radarGetBgpRouteLeakEventsWithHttpInfo(page, perPage, eventId, leakAsn, involvedAsn, involvedCountry, dateRange, dateStart, dateEnd, sortBy, sortOrder, format);
        return localVarResp.getData();
    }

    /**
     * Get BGP route leak events
     * Get the BGP route leak events (Beta).
     * @param page  (optional)
     * @param perPage  (optional)
     * @param eventId  (optional)
     * @param leakAsn  (optional)
     * @param involvedAsn  (optional)
     * @param involvedCountry  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param sortBy  (optional)
     * @param sortOrder  (optional)
     * @param format  (optional)
     * @return ApiResponse&lt;RadarGetBgpRouteLeakEvents200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RadarGetBgpRouteLeakEvents200Response> radarGetBgpRouteLeakEventsWithHttpInfo(Integer page, Integer perPage, Integer eventId, Integer leakAsn, Integer involvedAsn, String involvedCountry, String dateRange, OffsetDateTime dateStart, OffsetDateTime dateEnd, String sortBy, String sortOrder, String format) throws ApiException {
        okhttp3.Call localVarCall = radarGetBgpRouteLeakEventsValidateBeforeCall(page, perPage, eventId, leakAsn, involvedAsn, involvedCountry, dateRange, dateStart, dateEnd, sortBy, sortOrder, format, null);
        Type localVarReturnType = new TypeToken<RadarGetBgpRouteLeakEvents200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get BGP route leak events (asynchronously)
     * Get the BGP route leak events (Beta).
     * @param page  (optional)
     * @param perPage  (optional)
     * @param eventId  (optional)
     * @param leakAsn  (optional)
     * @param involvedAsn  (optional)
     * @param involvedCountry  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param sortBy  (optional)
     * @param sortOrder  (optional)
     * @param format  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpRouteLeakEventsAsync(Integer page, Integer perPage, Integer eventId, Integer leakAsn, Integer involvedAsn, String involvedCountry, String dateRange, OffsetDateTime dateStart, OffsetDateTime dateEnd, String sortBy, String sortOrder, String format, final ApiCallback<RadarGetBgpRouteLeakEvents200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = radarGetBgpRouteLeakEventsValidateBeforeCall(page, perPage, eventId, leakAsn, involvedAsn, involvedCountry, dateRange, dateStart, dateEnd, sortBy, sortOrder, format, _callback);
        Type localVarReturnType = new TypeToken<RadarGetBgpRouteLeakEvents200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for radarGetBgpRoutesStats
     * @param asn  (optional)
     * @param location  (optional)
     * @param format  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpRoutesStatsCall(Integer asn, String location, String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/radar/bgp/routes/stats";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (asn != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("asn", asn));
        }

        if (location != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("location", location));
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_token", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call radarGetBgpRoutesStatsValidateBeforeCall(Integer asn, String location, String format, final ApiCallback _callback) throws ApiException {
        return radarGetBgpRoutesStatsCall(asn, location, format, _callback);

    }

    /**
     * Get BGP routing table stats 
     * Get the BGP routing table stats (Beta).
     * @param asn  (optional)
     * @param location  (optional)
     * @param format  (optional)
     * @return RadarGetBgpRoutesStats200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public RadarGetBgpRoutesStats200Response radarGetBgpRoutesStats(Integer asn, String location, String format) throws ApiException {
        ApiResponse<RadarGetBgpRoutesStats200Response> localVarResp = radarGetBgpRoutesStatsWithHttpInfo(asn, location, format);
        return localVarResp.getData();
    }

    /**
     * Get BGP routing table stats 
     * Get the BGP routing table stats (Beta).
     * @param asn  (optional)
     * @param location  (optional)
     * @param format  (optional)
     * @return ApiResponse&lt;RadarGetBgpRoutesStats200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RadarGetBgpRoutesStats200Response> radarGetBgpRoutesStatsWithHttpInfo(Integer asn, String location, String format) throws ApiException {
        okhttp3.Call localVarCall = radarGetBgpRoutesStatsValidateBeforeCall(asn, location, format, null);
        Type localVarReturnType = new TypeToken<RadarGetBgpRoutesStats200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get BGP routing table stats  (asynchronously)
     * Get the BGP routing table stats (Beta).
     * @param asn  (optional)
     * @param location  (optional)
     * @param format  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpRoutesStatsAsync(Integer asn, String location, String format, final ApiCallback<RadarGetBgpRoutesStats200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = radarGetBgpRoutesStatsValidateBeforeCall(asn, location, format, _callback);
        Type localVarReturnType = new TypeToken<RadarGetBgpRoutesStats200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for radarGetBgpTimeseries
     * @param aggInterval  (optional)
     * @param name  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param prefix  (optional)
     * @param updateType  (optional)
     * @param asn  (optional)
     * @param format  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpTimeseriesCall(String aggInterval, List<String> name, List<String> dateRange, List<OffsetDateTime> dateStart, List<OffsetDateTime> dateEnd, List<String> prefix, List<String> updateType, List<String> asn, String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/radar/bgp/timeseries";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (aggInterval != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("aggInterval", aggInterval));
        }

        if (name != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "name", name));
        }

        if (dateRange != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "dateRange", dateRange));
        }

        if (dateStart != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "dateStart", dateStart));
        }

        if (dateEnd != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "dateEnd", dateEnd));
        }

        if (prefix != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "prefix", prefix));
        }

        if (updateType != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "updateType", updateType));
        }

        if (asn != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "asn", asn));
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_token", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call radarGetBgpTimeseriesValidateBeforeCall(String aggInterval, List<String> name, List<String> dateRange, List<OffsetDateTime> dateStart, List<OffsetDateTime> dateEnd, List<String> prefix, List<String> updateType, List<String> asn, String format, final ApiCallback _callback) throws ApiException {
        return radarGetBgpTimeseriesCall(aggInterval, name, dateRange, dateStart, dateEnd, prefix, updateType, asn, format, _callback);

    }

    /**
     * Get BGP time series
     * Gets BGP updates change over time. Raw values are returned. When requesting updates of an autonomous system (AS), only BGP updates of type announcement are returned.
     * @param aggInterval  (optional)
     * @param name  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param prefix  (optional)
     * @param updateType  (optional)
     * @param asn  (optional)
     * @param format  (optional)
     * @return RadarGetDnsAs112Timeseries200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public RadarGetDnsAs112Timeseries200Response radarGetBgpTimeseries(String aggInterval, List<String> name, List<String> dateRange, List<OffsetDateTime> dateStart, List<OffsetDateTime> dateEnd, List<String> prefix, List<String> updateType, List<String> asn, String format) throws ApiException {
        ApiResponse<RadarGetDnsAs112Timeseries200Response> localVarResp = radarGetBgpTimeseriesWithHttpInfo(aggInterval, name, dateRange, dateStart, dateEnd, prefix, updateType, asn, format);
        return localVarResp.getData();
    }

    /**
     * Get BGP time series
     * Gets BGP updates change over time. Raw values are returned. When requesting updates of an autonomous system (AS), only BGP updates of type announcement are returned.
     * @param aggInterval  (optional)
     * @param name  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param prefix  (optional)
     * @param updateType  (optional)
     * @param asn  (optional)
     * @param format  (optional)
     * @return ApiResponse&lt;RadarGetDnsAs112Timeseries200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RadarGetDnsAs112Timeseries200Response> radarGetBgpTimeseriesWithHttpInfo(String aggInterval, List<String> name, List<String> dateRange, List<OffsetDateTime> dateStart, List<OffsetDateTime> dateEnd, List<String> prefix, List<String> updateType, List<String> asn, String format) throws ApiException {
        okhttp3.Call localVarCall = radarGetBgpTimeseriesValidateBeforeCall(aggInterval, name, dateRange, dateStart, dateEnd, prefix, updateType, asn, format, null);
        Type localVarReturnType = new TypeToken<RadarGetDnsAs112Timeseries200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get BGP time series (asynchronously)
     * Gets BGP updates change over time. Raw values are returned. When requesting updates of an autonomous system (AS), only BGP updates of type announcement are returned.
     * @param aggInterval  (optional)
     * @param name  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param prefix  (optional)
     * @param updateType  (optional)
     * @param asn  (optional)
     * @param format  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpTimeseriesAsync(String aggInterval, List<String> name, List<String> dateRange, List<OffsetDateTime> dateStart, List<OffsetDateTime> dateEnd, List<String> prefix, List<String> updateType, List<String> asn, String format, final ApiCallback<RadarGetDnsAs112Timeseries200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = radarGetBgpTimeseriesValidateBeforeCall(aggInterval, name, dateRange, dateStart, dateEnd, prefix, updateType, asn, format, _callback);
        Type localVarReturnType = new TypeToken<RadarGetDnsAs112Timeseries200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for radarGetBgpTopAses
     * @param limit  (optional)
     * @param name  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param asn  (optional)
     * @param prefix  (optional)
     * @param updateType  (optional)
     * @param format  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpTopAsesCall(Integer limit, List<String> name, List<String> dateRange, List<OffsetDateTime> dateStart, List<OffsetDateTime> dateEnd, List<String> asn, List<String> prefix, List<String> updateType, String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/radar/bgp/top/ases";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (name != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "name", name));
        }

        if (dateRange != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "dateRange", dateRange));
        }

        if (dateStart != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "dateStart", dateStart));
        }

        if (dateEnd != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "dateEnd", dateEnd));
        }

        if (asn != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "asn", asn));
        }

        if (prefix != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "prefix", prefix));
        }

        if (updateType != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "updateType", updateType));
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_token", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call radarGetBgpTopAsesValidateBeforeCall(Integer limit, List<String> name, List<String> dateRange, List<OffsetDateTime> dateStart, List<OffsetDateTime> dateEnd, List<String> asn, List<String> prefix, List<String> updateType, String format, final ApiCallback _callback) throws ApiException {
        return radarGetBgpTopAsesCall(limit, name, dateRange, dateStart, dateEnd, asn, prefix, updateType, format, _callback);

    }

    /**
     * Get top autonomous systems
     * Get the top autonomous systems (AS) by BGP updates (announcements only). Values are a percentage out of the total updates.
     * @param limit  (optional)
     * @param name  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param asn  (optional)
     * @param prefix  (optional)
     * @param updateType  (optional)
     * @param format  (optional)
     * @return RadarGetBgpTopAses200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public RadarGetBgpTopAses200Response radarGetBgpTopAses(Integer limit, List<String> name, List<String> dateRange, List<OffsetDateTime> dateStart, List<OffsetDateTime> dateEnd, List<String> asn, List<String> prefix, List<String> updateType, String format) throws ApiException {
        ApiResponse<RadarGetBgpTopAses200Response> localVarResp = radarGetBgpTopAsesWithHttpInfo(limit, name, dateRange, dateStart, dateEnd, asn, prefix, updateType, format);
        return localVarResp.getData();
    }

    /**
     * Get top autonomous systems
     * Get the top autonomous systems (AS) by BGP updates (announcements only). Values are a percentage out of the total updates.
     * @param limit  (optional)
     * @param name  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param asn  (optional)
     * @param prefix  (optional)
     * @param updateType  (optional)
     * @param format  (optional)
     * @return ApiResponse&lt;RadarGetBgpTopAses200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RadarGetBgpTopAses200Response> radarGetBgpTopAsesWithHttpInfo(Integer limit, List<String> name, List<String> dateRange, List<OffsetDateTime> dateStart, List<OffsetDateTime> dateEnd, List<String> asn, List<String> prefix, List<String> updateType, String format) throws ApiException {
        okhttp3.Call localVarCall = radarGetBgpTopAsesValidateBeforeCall(limit, name, dateRange, dateStart, dateEnd, asn, prefix, updateType, format, null);
        Type localVarReturnType = new TypeToken<RadarGetBgpTopAses200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get top autonomous systems (asynchronously)
     * Get the top autonomous systems (AS) by BGP updates (announcements only). Values are a percentage out of the total updates.
     * @param limit  (optional)
     * @param name  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param asn  (optional)
     * @param prefix  (optional)
     * @param updateType  (optional)
     * @param format  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpTopAsesAsync(Integer limit, List<String> name, List<String> dateRange, List<OffsetDateTime> dateStart, List<OffsetDateTime> dateEnd, List<String> asn, List<String> prefix, List<String> updateType, String format, final ApiCallback<RadarGetBgpTopAses200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = radarGetBgpTopAsesValidateBeforeCall(limit, name, dateRange, dateStart, dateEnd, asn, prefix, updateType, format, _callback);
        Type localVarReturnType = new TypeToken<RadarGetBgpTopAses200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for radarGetBgpTopAsnsByPrefixes
     * @param country  (optional)
     * @param limit  (optional)
     * @param format  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpTopAsnsByPrefixesCall(String country, Integer limit, String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/radar/bgp/top/ases/prefixes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (country != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("country", country));
        }

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_token", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call radarGetBgpTopAsnsByPrefixesValidateBeforeCall(String country, Integer limit, String format, final ApiCallback _callback) throws ApiException {
        return radarGetBgpTopAsnsByPrefixesCall(country, limit, format, _callback);

    }

    /**
     * Get list of ASNs ordered by prefix count
     * Get the full list of autonomous systems on the global routing table ordered by announced prefixes count. The data comes from public BGP MRT data archives and updates every 2 hours.
     * @param country  (optional)
     * @param limit  (optional)
     * @param format  (optional)
     * @return RadarGetBgpTopAsnsByPrefixes200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not found </td><td>  -  </td></tr>
     </table>
     */
    public RadarGetBgpTopAsnsByPrefixes200Response radarGetBgpTopAsnsByPrefixes(String country, Integer limit, String format) throws ApiException {
        ApiResponse<RadarGetBgpTopAsnsByPrefixes200Response> localVarResp = radarGetBgpTopAsnsByPrefixesWithHttpInfo(country, limit, format);
        return localVarResp.getData();
    }

    /**
     * Get list of ASNs ordered by prefix count
     * Get the full list of autonomous systems on the global routing table ordered by announced prefixes count. The data comes from public BGP MRT data archives and updates every 2 hours.
     * @param country  (optional)
     * @param limit  (optional)
     * @param format  (optional)
     * @return ApiResponse&lt;RadarGetBgpTopAsnsByPrefixes200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not found </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RadarGetBgpTopAsnsByPrefixes200Response> radarGetBgpTopAsnsByPrefixesWithHttpInfo(String country, Integer limit, String format) throws ApiException {
        okhttp3.Call localVarCall = radarGetBgpTopAsnsByPrefixesValidateBeforeCall(country, limit, format, null);
        Type localVarReturnType = new TypeToken<RadarGetBgpTopAsnsByPrefixes200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get list of ASNs ordered by prefix count (asynchronously)
     * Get the full list of autonomous systems on the global routing table ordered by announced prefixes count. The data comes from public BGP MRT data archives and updates every 2 hours.
     * @param country  (optional)
     * @param limit  (optional)
     * @param format  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Not found </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpTopAsnsByPrefixesAsync(String country, Integer limit, String format, final ApiCallback<RadarGetBgpTopAsnsByPrefixes200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = radarGetBgpTopAsnsByPrefixesValidateBeforeCall(country, limit, format, _callback);
        Type localVarReturnType = new TypeToken<RadarGetBgpTopAsnsByPrefixes200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for radarGetBgpTopPrefixes
     * @param limit  (optional)
     * @param name  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param asn  (optional)
     * @param updateType  (optional)
     * @param format  (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpTopPrefixesCall(Integer limit, List<String> name, List<String> dateRange, List<OffsetDateTime> dateStart, List<OffsetDateTime> dateEnd, List<String> asn, List<String> updateType, String format, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/radar/bgp/top/prefixes";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (name != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "name", name));
        }

        if (dateRange != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "dateRange", dateRange));
        }

        if (dateStart != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "dateStart", dateStart));
        }

        if (dateEnd != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "dateEnd", dateEnd));
        }

        if (asn != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "asn", asn));
        }

        if (updateType != null) {
            localVarCollectionQueryParams.addAll(localVarApiClient.parameterToPairs("multi", "updateType", updateType));
        }

        if (format != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("format", format));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "api_key", "api_token", "api_email" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call radarGetBgpTopPrefixesValidateBeforeCall(Integer limit, List<String> name, List<String> dateRange, List<OffsetDateTime> dateStart, List<OffsetDateTime> dateEnd, List<String> asn, List<String> updateType, String format, final ApiCallback _callback) throws ApiException {
        return radarGetBgpTopPrefixesCall(limit, name, dateRange, dateStart, dateEnd, asn, updateType, format, _callback);

    }

    /**
     * Get top prefixes
     * Get the top network prefixes by BGP updates. Values are a percentage out of the total BGP updates.
     * @param limit  (optional)
     * @param name  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param asn  (optional)
     * @param updateType  (optional)
     * @param format  (optional)
     * @return RadarGetBgpTopPrefixes200Response
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public RadarGetBgpTopPrefixes200Response radarGetBgpTopPrefixes(Integer limit, List<String> name, List<String> dateRange, List<OffsetDateTime> dateStart, List<OffsetDateTime> dateEnd, List<String> asn, List<String> updateType, String format) throws ApiException {
        ApiResponse<RadarGetBgpTopPrefixes200Response> localVarResp = radarGetBgpTopPrefixesWithHttpInfo(limit, name, dateRange, dateStart, dateEnd, asn, updateType, format);
        return localVarResp.getData();
    }

    /**
     * Get top prefixes
     * Get the top network prefixes by BGP updates. Values are a percentage out of the total BGP updates.
     * @param limit  (optional)
     * @param name  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param asn  (optional)
     * @param updateType  (optional)
     * @param format  (optional)
     * @return ApiResponse&lt;RadarGetBgpTopPrefixes200Response&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<RadarGetBgpTopPrefixes200Response> radarGetBgpTopPrefixesWithHttpInfo(Integer limit, List<String> name, List<String> dateRange, List<OffsetDateTime> dateStart, List<OffsetDateTime> dateEnd, List<String> asn, List<String> updateType, String format) throws ApiException {
        okhttp3.Call localVarCall = radarGetBgpTopPrefixesValidateBeforeCall(limit, name, dateRange, dateStart, dateEnd, asn, updateType, format, null);
        Type localVarReturnType = new TypeToken<RadarGetBgpTopPrefixes200Response>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get top prefixes (asynchronously)
     * Get the top network prefixes by BGP updates. Values are a percentage out of the total BGP updates.
     * @param limit  (optional)
     * @param name  (optional)
     * @param dateRange  (optional)
     * @param dateStart  (optional)
     * @param dateEnd  (optional)
     * @param asn  (optional)
     * @param updateType  (optional)
     * @param format  (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Bad Request </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call radarGetBgpTopPrefixesAsync(Integer limit, List<String> name, List<String> dateRange, List<OffsetDateTime> dateStart, List<OffsetDateTime> dateEnd, List<String> asn, List<String> updateType, String format, final ApiCallback<RadarGetBgpTopPrefixes200Response> _callback) throws ApiException {

        okhttp3.Call localVarCall = radarGetBgpTopPrefixesValidateBeforeCall(limit, name, dateRange, dateStart, dateEnd, asn, updateType, format, _callback);
        Type localVarReturnType = new TypeToken<RadarGetBgpTopPrefixes200Response>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
